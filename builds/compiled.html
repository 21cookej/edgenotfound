<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Edge Not Found</title>
    <style>html, body, canvas {width:100%;height: 100%;margin: 0;overflow: hidden;}</style>
    
    <script> class Timing { constructor(minimumFrameLength, maximumFrameLength) { this.minimumFrameLength = minimumFrameLength; this.maximumFrameLength = maximumFrameLength; this.lastUpdate = new Date();this.currentFrameLength = 0; this.stepsProcessed = 0; this.timePlaying = 0; }update(overwrite = null) { const newUpdate = new Date();if (!overwrite) { this.currentFrameLength = (newUpdate - this.lastUpdate) / 1000; } else { this.currentFrameLength = overwrite; }this.lastUpdate = newUpdate; this.timePlaying += this.currentFrameLength; this.stepsProcessed += 1; }get fps() { return (1 / this.currentFrameLength) }perSecond(v) { return v * this.currentFrameLength; } }const pressedState = { IDLE: 0, PRESSED: 1, HELD: 2, RELEASED: 3 };class InputHandler { constructor(positiveKeys, negativeKeys = null, timer = null, timeForRefiring = 0, extraTimeForFirstRefire = 0) { this.delta = 0; this.posKeysHeld = []; this.negKeysHeld = []; this.timer = timer; this.prevHeldTime = 0; this.heldTime = 0;this.waitForRefiring = timeForRefiring; this.firstWaitForRefiring = timeForRefiring + extraTimeForFirstRefire; this.timeSinceLastRefire = 0; this.timesFired = 0;this.state = pressedState.IDLE;if (positiveKeys) { positiveKeys.forEach((element) => { window.addEventListener('keydown', (event) => { if (this.change(event, element)) { var push = PushUnique(this.posKeysHeld, element); if (push.changed) { this.posKeysHeld = push.array; this.updateDelta(); } } }); window.addEventListener('keyup', (event) => { if (this.change(event, element)) { this.posKeysHeld = SpliceUnique(this.posKeysHeld, element); this.updateDelta(); } }); }); } this.positiveKeys = positiveKeys;if (negativeKeys) { negativeKeys.forEach((element) => { window.addEventListener('keydown', (event) => { if (this.change(event, element)) { var push = PushUnique(this.negKeysHeld, element); if (push.changed) { this.negKeysHeld = push.array; this.updateDelta(); } } }); window.addEventListener('keyup', (event) => { if (this.change(event, element)) { this.negKeysHeld = SpliceUnique(this.negKeysHeld, element); this.updateDelta(); } }); }); } this.negativeKeys = negativeKeys; }change(event, element) { return (event.code == element || event.keyCode == element); }updateDelta() { const diff = this.posKeysHeld.length - this.negKeysHeld.length; if (diff > 0 && this.delta != 1) { this.delta = 1; this.heldTime = 0; this.timesFired = 0; this.timeSinceLastRefire = 0; } else if (diff < 0 && this.delta != -1) { this.delta = -1; this.heldTime = 0; this.timesFired = 0; this.timeSinceLastRefire = 0; } else if (this.delta != 0) { this.delta = 0; this.heldTime = 0; this.timesFired = 0; this.timeSinceLastRefire = 0; } }update() { if (this.timer && this.delta != 0) { this.heldTime += this.timer.currentFrameLength; this.timeSinceLastRefire += this.timer.currentFrameLength;if (this.prevHeldTime == 0 || (this.timesFired > 1 && this.timeSinceLastRefire >= this.waitForRefiring) || (this.timesFired <= 1 && this.timeSinceLastRefire >= this.firstWaitForRefiring)) { this.fired = true; this.timesFired += 1; this.timeSinceLastRefire = 0; } else { this.fired = false; } } else { this.fired = false; } if (this.delta == 0) { if (this.prevHeldTime != 0) { this.state = pressedState.RELEASED; } else { this.state = pressedState.IDLE; } } else { if (this.prevHeldTime == 0) { this.state = pressedState.PRESSED; } else { this.state = pressedState.HELD; } }this.prevHeldTime = this.heldTime; } }function Clamp(nr, min, max) { return Math.max(min, Math.min(nr, max)); }function PushUnique(array, newEntry) { var changed = false; if (array.indexOf(newEntry) === -1) { array.push(newEntry); changed = true; } return {array: array, changed: changed}; }function SpliceUnique(array, EntryToSplice) { const index = array.indexOf(EntryToSplice); if (index > -1) { array.splice(index, 1); } return array; }console.log("üçÖ Tomato loaded successfully! Version 0.1.0")</script>
    
    <script>var rough=function(){"use strict";function t(t,e,s){if(t&&t.length){const[n,o]=e,a=Math.PI/180*s,r=Math.cos(a),h=Math.sin(a);t.forEach(t=>{const[e,s]=t;t[0]=(e-n)*r-(s-o)*h+n,t[1]=(e-n)*h+(s-o)*r+o})}}function e(t){const e=t[0],s=t[1];return Math.sqrt(Math.pow(e[0]-s[0],2)+Math.pow(e[1]-s[1],2))}function s(t,e,s,n){const o=e[1]-t[1],a=t[0]-e[0],r=o*t[0]+a*t[1],h=n[1]-s[1],i=s[0]-n[0],c=h*s[0]+i*s[1],l=o*i-h*a;return l?[(i*r-a*c)/l,(o*c-h*r)/l]:null}function n(t,e,s){const n=t.length;if(n<3)return!1;const h=[Number.MAX_SAFE_INTEGER,s],i=[e,s];let c=0;for(let e=0;e<n;e++){const s=t[e],l=t[(e+1)%n];if(r(s,l,i,h)){if(0===a(s,i,l))return o(s,i,l);c++}}return c%2==1}function o(t,e,s){return e[0]<=Math.max(t[0],s[0])&&e[0]>=Math.min(t[0],s[0])&&e[1]<=Math.max(t[1],s[1])&&e[1]>=Math.min(t[1],s[1])}function a(t,e,s){const n=(e[1]-t[1])*(s[0]-e[0])-(e[0]-t[0])*(s[1]-e[1]);return 0===n?0:n>0?1:2}function r(t,e,s,n){const r=a(t,e,s),h=a(t,e,n),i=a(s,n,t),c=a(s,n,e);return r!==h&&i!==c||(!(0!==r||!o(t,s,e))||(!(0!==h||!o(t,n,e))||(!(0!==i||!o(s,t,n))||!(0!==c||!o(s,e,n)))))}function h(e,s){const n=[0,0],o=Math.round(s.hachureAngle+90);o&&t(e,n,o);const a=function(t,e){const s=[...t];s[0].join(",")!==s[s.length-1].join(",")&&s.push([s[0][0],s[0][1]]);const n=[];if(s&&s.length>2){let t=e.hachureGap;t<0&&(t=4*e.strokeWidth),t=Math.max(t,.1);const o=[];for(let t=0;t<s.length-1;t++){const e=s[t],n=s[t+1];if(e[1]!==n[1]){const t=Math.min(e[1],n[1]);o.push({ymin:t,ymax:Math.max(e[1],n[1]),x:t===e[1]?e[0]:n[0],islope:(n[0]-e[0])/(n[1]-e[1])})}}if(o.sort((t,e)=>t.ymin<e.ymin?-1:t.ymin>e.ymin?1:t.x<e.x?-1:t.x>e.x?1:t.ymax===e.ymax?0:(t.ymax-e.ymax)/Math.abs(t.ymax-e.ymax)),!o.length)return n;let a=[],r=o[0].ymin;for(;a.length||o.length;){if(o.length){let t=-1;for(let e=0;e<o.length&&!(o[e].ymin>r);e++)t=e;o.splice(0,t+1).forEach(t=>{a.push({s:r,edge:t})})}if(a=a.filter(t=>!(t.edge.ymax<=r)),a.sort((t,e)=>t.edge.x===e.edge.x?0:(t.edge.x-e.edge.x)/Math.abs(t.edge.x-e.edge.x)),a.length>1)for(let t=0;t<a.length;t+=2){const e=t+1;if(e>=a.length)break;const s=a[t].edge,o=a[e].edge;n.push([[Math.round(s.x),r],[Math.round(o.x),r]])}r+=t,a.forEach(e=>{e.edge.x=e.edge.x+t*e.edge.islope})}}return n}(e,s);return o&&(t(e,n,-o),function(e,s,n){const o=[];e.forEach(t=>o.push(...t)),t(o,s,n)}(a,n,-o)),a} class i{constructor(t){this.helper=t}fillPolygon(t,e){return this._fillPolygon(t,e)}_fillPolygon(t,e,s=!1){let n=h(t,e);if(s){const e=this.connectingLines(t,n);n=n.concat(e)}return{type:"fillSketch",ops:this.renderLines(n,e)}}renderLines(t,e){const s=[];for(const n of t)s.push(...this.helper.doubleLineOps(n[0][0],n[0][1],n[1][0],n[1][1],e));return s}connectingLines(t,s){const n=[];if(s.length>1)for(let o=1;o<s.length;o++){const a=s[o-1];if(e(a)<3)continue;const r=[s[o][0],a[1]];if(e(r)>3){const e=this.splitOnIntersections(t,r);n.push(...e)}}return n}midPointInPolygon(t,e){return n(t,(e[0][0]+e[1][0])/2,(e[0][1]+e[1][1])/2)}splitOnIntersections(t,o){const a=Math.max(5,.1*e(o)),h=[];for(let n=0;n<t.length;n++){const i=t[n],c=t[(n+1)%t.length];if(r(i,c,...o)){const t=s(i,c,o[0],o[1]);if(t){const s=e([t,o[0]]),n=e([t,o[1]]);s>a&&n>a&&h.push({point:t,distance:s})}}}if(h.length>1){const e=h.sort((t,e)=>t.distance-e.distance).map(t=>t.point);if(n(t,...o[0])||e.shift(),n(t,...o[1])||e.pop(),e.length<=1)return this.midPointInPolygon(t,o)?[o]:[];const s=[o[0],...e,o[1]],a=[];for(let e=0;e<s.length-1;e+=2){const n=[s[e],s[e+1]];this.midPointInPolygon(t,n)&&a.push(n)}return a}return this.midPointInPolygon(t,o)?[o]:[]}} class c extends i{fillPolygon(t,e){return this._fillPolygon(t,e,!0)}} class l extends i{fillPolygon(t,e){const s=this._fillPolygon(t,e),n=Object.assign({},e,{hachureAngle:e.hachureAngle+90}),o=this._fillPolygon(t,n);return s.ops=s.ops.concat(o.ops),s}} class u{constructor(t){this.helper=t}fillPolygon(t,e){const s=h(t,e=Object.assign({},e,{curveStepCount:4,hachureAngle:0,roughness:1}));return this.dotsOnLines(s,e)}dotsOnLines(t,s){const n=[];let o=s.hachureGap;o<0&&(o=4*s.strokeWidth),o=Math.max(o,.1);let a=s.fillWeight;a<0&&(a=s.strokeWidth/2);const r=o/4;for(const h of t){const t=e(h),i=t/o,c=Math.ceil(i)-1,l=t-c*o,u=(h[0][0]+h[1][0])/2-o/4,f=Math.min(h[0][1],h[1][1]);for(let t=0;t<c;t++){const e=f+l+t*o,h=this.helper.randOffsetWithRange(u-r,u+r,s),i=this.helper.randOffsetWithRange(e-r,e+r,s),c=this.helper.ellipse(h,i,a,a,s);n.push(...c.ops)}}return{type:"fillSketch",ops:n}}} class f{constructor(t){this.helper=t}fillPolygon(t,e){const s=h(t,e);return{type:"fillSketch",ops:this.dashedLine(s,e)}}dashedLine(t,s){const n=s.dashOffset<0?s.hachureGap<0?4*s.strokeWidth:s.hachureGap:s.dashOffset,o=s.dashGap<0?s.hachureGap<0?4*s.strokeWidth:s.hachureGap:s.dashGap,a=[];return t.forEach(t=>{const r=e(t),h=Math.floor(r/(n+o)),i=(r+o-h*(n+o))/2;let c=t[0],l=t[1];c[0]>l[0]&&(c=t[1],l=t[0]);const u=Math.atan((l[1]-c[1])/(l[0]-c[0]));for(let t=0;t<h;t++){const e=t*(n+o),r=e+n,h=[c[0]+e*Math.cos(u)+i*Math.cos(u),c[1]+e*Math.sin(u)+i*Math.sin(u)],l=[c[0]+r*Math.cos(u)+i*Math.cos(u),c[1]+r*Math.sin(u)+i*Math.sin(u)];a.push(...this.helper.doubleLineOps(h[0],h[1],l[0],l[1],s))}}),a}} class p{constructor(t){this.helper=t}fillPolygon(t,e){const s=e.hachureGap<0?4*e.strokeWidth:e.hachureGap,n=e.zigzagOffset<0?s:e.zigzagOffset,o=h(t,e=Object.assign({},e,{hachureGap:s+n}));return{type:"fillSketch",ops:this.zigzagLines(o,n,e)}}zigzagLines(t,s,n){const o=[];return t.forEach(t=>{const a=e(t),r=Math.round(a/(2*s));let h=t[0],i=t[1];h[0]>i[0]&&(h=t[1],i=t[0]);const c=Math.atan((i[1]-h[1])/(i[0]-h[0]));for(let t=0;t<r;t++){const e=2*t*s,a=2*(t+1)*s,r=Math.sqrt(2*Math.pow(s,2)),i=[h[0]+e*Math.cos(c),h[1]+e*Math.sin(c)],l=[h[0]+a*Math.cos(c),h[1]+a*Math.sin(c)],u=[i[0]+r*Math.cos(c+Math.PI/4),i[1]+r*Math.sin(c+Math.PI/4)];o.push(...this.helper.doubleLineOps(i[0],i[1],u[0],u[1],n),...this.helper.doubleLineOps(u[0],u[1],l[0],l[1],n))}}),o}}const d={}; class g{constructor(t){this.seed=t}next(){return this.seed?(2**31-1&(this.seed=Math.imul(48271,this.seed)))/2**31:Math.random()}}const M={A:7,a:7,C:6,c:6,H:1,h:1,L:2,l:2,M:2,m:2,Q:4,q:4,S:4,s:4,T:2,t:2,V:1,v:1,Z:0,z:0};function k(t,e){return t.type===e}function b(t){const e=[],s=function(t){const e=new Array;for(;""!==t;)if(t.match(/^([ \t\r\n,]+)/))t=t.substr(RegExp.$1.length);else if(t.match(/^([aAcChHlLmMqQsStTvVzZ])/))e[e.length]={type:0,text:RegExp.$1},t=t.substr(RegExp.$1.length);else{if(!t.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/))return[];e[e.length]={type:1,text:""+parseFloat(RegExp.$1)},t=t.substr(RegExp.$1.length)}return e[e.length]={type:2,text:""},e}(t);let n="BOD",o=0,a=s[o];for(;!k(a,2);){let r=0;const h=[];if("BOD"===n){if("M"!==a.text&&"m"!==a.text)return b("M0,0"+t);o++,r=M[a.text],n=a.text}else k(a,1)?r=M[n]:(o++,r=M[a.text],n=a.text);if(!(o+r<s.length))throw new Error("Path data ended short");for(let t=o;t<o+r;t++){const e=s[t];if(!k(e,1))throw new Error("Param not a number: "+n+","+e.text);h[h.length]=+e.text}if("number"!=typeof M[n])throw new Error("Bad segment: "+n);{const t={key:n,data:h};e.push(t),o+=r,a=s[o],"M"===n&&(n="L"),"m"===n&&(n="l")}}return e}function y(t){let e=0,s=0,n=0,o=0;const a=[];for(const{key:r,data:h}of t)switch(r){case"M":a.push({key:"M",data:[...h]}),[e,s]=h,[n,o]=h;break;case"m":e+=h[0],s+=h[1],a.push({key:"M",data:[e,s]}),n=e,o=s;break;case"L":a.push({key:"L",data:[...h]}),[e,s]=h;break;case"l":e+=h[0],s+=h[1],a.push({key:"L",data:[e,s]});break;case"C":a.push({key:"C",data:[...h]}),e=h[4],s=h[5];break;case"c":{const t=h.map((t,n)=>n%2?t+s:t+e);a.push({key:"C",data:t}),e=t[4],s=t[5];break}case"Q":a.push({key:"Q",data:[...h]}),e=h[2],s=h[3];break;case"q":{const t=h.map((t,n)=>n%2?t+s:t+e);a.push({key:"Q",data:t}),e=t[2],s=t[3];break}case"A":a.push({key:"A",data:[...h]}),e=h[5],s=h[6];break;case"a":e+=h[5],s+=h[6],a.push({key:"A",data:[h[0],h[1],h[2],h[3],h[4],e,s]});break;case"H":a.push({key:"H",data:[...h]}),e=h[0];break;case"h":e+=h[0],a.push({key:"H",data:[e]});break;case"V":a.push({key:"V",data:[...h]}),s=h[0];break;case"v":s+=h[0],a.push({key:"V",data:[s]});break;case"S":a.push({key:"S",data:[...h]}),e=h[2],s=h[3];break;case"s":{const t=h.map((t,n)=>n%2?t+s:t+e);a.push({key:"S",data:t}),e=t[2],s=t[3];break}case"T":a.push({key:"T",data:[...h]}),e=h[0],s=h[1];break;case"t":e+=h[0],s+=h[1],a.push({key:"T",data:[e,s]});break;case"Z":case"z":a.push({key:"Z",data:[]}),e=n,s=o}return a}function m(t){const e=[];let s="",n=0,o=0,a=0,r=0,h=0,i=0;for(const{key:c,data:l}of t){switch(c){case"M":e.push({key:"M",data:[...l]}),[n,o]=l,[a,r]=l;break;case"C":e.push({key:"C",data:[...l]}),n=l[4],o=l[5],h=l[2],i=l[3];break;case"L":e.push({key:"L",data:[...l]}),[n,o]=l;break;case"H":n=l[0],e.push({key:"L",data:[n,o]});break;case"V":o=l[0],e.push({key:"L",data:[n,o]});break;case"S":{let t=0,a=0;"C"===s||"S"===s?(t=n+(n-h),a=o+(o-i)):(t=n,a=o),e.push({key:"C",data:[t,a,...l]}),h=l[0],i=l[1],n=l[2],o=l[3];break}case"T":{const[t,a]=l;let r=0,c=0;"Q"===s||"T"===s?(r=n+(n-h),c=o+(o-i)):(r=n,c=o);const u=n+2*(r-n)/3,f=o+2*(c-o)/3,p=t+2*(r-t)/3,d=a+2*(c-a)/3;e.push({key:"C",data:[u,f,p,d,t,a]}),h=r,i=c,n=t,o=a;break}case"Q":{const[t,s,a,r]=l,c=n+2*(t-n)/3,u=o+2*(s-o)/3,f=a+2*(t-a)/3,p=r+2*(s-r)/3;e.push({key:"C",data:[c,u,f,p,a,r]}),h=t,i=s,n=a,o=r;break}case"A":{const t=Math.abs(l[0]),s=Math.abs(l[1]),a=l[2],r=l[3],h=l[4],i=l[5],c=l[6];if(0===t||0===s)e.push({key:"C",data:[n,o,i,c,i,c]}),n=i,o=c;else if(n!==i||o!==c){P(n,o,i,c,t,s,a,r,h).forEach((function(t){e.push({key:"C",data:t})})),n=i,o=c}break}case"Z":e.push({key:"Z",data:[]}),n=a,o=r}s=c}return e}function w(t,e,s){return[t*Math.cos(s)-e*Math.sin(s),t*Math.sin(s)+e*Math.cos(s)]}function P(t,e,s,n,o,a,r,h,i,c){const l=(u=r,Math.PI*u/180);var u;let f=[],p=0,d=0,g=0,M=0;if(c)[p,d,g,M]=c;else{[t,e]=w(t,e,-l),[s,n]=w(s,n,-l);const r=(t-s)/2,c=(e-n)/2;let u=r*r/(o*o)+c*c/(a*a);u>1&&(u=Math.sqrt(u),o*=u,a*=u);const f=o*o,k=a*a,b=f*k-f*c*c-k*r*r,y=f*c*c+k*r*r,m=(h===i?-1:1)*Math.sqrt(Math.abs(b/y));g=m*o*c/a+(t+s)/2,M=m*-a*r/o+(e+n)/2,p=Math.asin(parseFloat(((e-M)/a).toFixed(9))),d=Math.asin(parseFloat(((n-M)/a).toFixed(9))),t<g&&(p=Math.PI-p),s<g&&(d=Math.PI-d),p<0&&(p=2*Math.PI+p),d<0&&(d=2*Math.PI+d),i&&p>d&&(p-=2*Math.PI),!i&&d>p&&(d-=2*Math.PI)}let k=d-p;if(Math.abs(k)>120*Math.PI/180){const t=d,e=s,h=n;d=i&&d>p?p+120*Math.PI/180*1:p+120*Math.PI/180*-1,f=P(s=g+o*Math.cos(d),n=M+a*Math.sin(d),e,h,o,a,r,0,i,[d,t,g,M])}k=d-p;const b=Math.cos(p),y=Math.sin(p),m=Math.cos(d),x=Math.sin(d),v=Math.tan(k/4),O=4/3*o*v,S=4/3*a*v,L=[t,e],T=[t+O*y,e-S*b],I=[s+O*x,n-S*m],A=[s,n];if(T[0]=2*L[0]-T[0],T[1]=2*L[1]-T[1],c)return[T,I,A].concat(f);{f=[T,I,A].concat(f);const t=[];for(let e=0;e<f.length;e+=3){const s=w(f[e][0],f[e][1],l),n=w(f[e+1][0],f[e+1][1],l),o=w(f[e+2][0],f[e+2][1],l);t.push([s[0],s[1],n[0],n[1],o[0],o[1]])}return t}}const x={randOffset:function(t,e){return W(t,e)},randOffsetWithRange:function(t,e,s){return E(t,e,s)},ellipse:function(t,e,s,n,o){const a=T(s,n,o);return I(t,e,o,a).opset},doubleLineOps:function(t,e,s,n,o){return z(t,e,s,n,o,!0)}};function v(t,e,s,n,o){return{type:"path",ops:z(t,e,s,n,o)}}function O(t,e,s){const n=(t||[]).length;if(n>2){const o=[];for(let e=0;e<n-1;e++)o.push(...z(t[e][0],t[e][1],t[e+1][0],t[e+1][1],s));return e&&o.push(...z(t[n-1][0],t[n-1][1],t[0][0],t[0][1],s)),{type:"path",ops:o}}return 2===n?v(t[0][0],t[0][1],t[1][0],t[1][1],s):{type:"path",ops:[]}}function S(t,e,s,n,o){return function(t,e){return O(t,!0,e)}([[t,e],[t+s,e],[t+s,e+n],[t,e+n]],o)}function L(t,e){let s=$(t,1*(1+.2*e.roughness),e);if(!e.disableMultiStroke){const n=$(t,1.5*(1+.22*e.roughness),function(t){const e=Object.assign({},t);e.randomizer=void 0,t.seed&&(e.seed=t.seed+1);return e}(e));s=s.concat(n)}return{type:"path",ops:s}}function T(t,e,s){const n=Math.sqrt(2*Math.PI*Math.sqrt((Math.pow(t/2,2)+Math.pow(e/2,2))/2)),o=Math.max(s.curveStepCount,s.curveStepCount/Math.sqrt(200)*n),a=2*Math.PI/o;let r=Math.abs(t/2),h=Math.abs(e/2);const i=1-s.curveFitting;return r+=W(r*i,s),h+=W(h*i,s),{increment:a,rx:r,ry:h}}function I(t,e,s,n){const[o,a]=q(n.increment,t,e,n.rx,n.ry,1,n.increment*E(.1,E(.4,1,s),s),s);let r=G(o,null,s);if(!s.disableMultiStroke){const[o]=q(n.increment,t,e,n.rx,n.ry,1.5,0,s),a=G(o,null,s);r=r.concat(a)}return{estimatedPoints:a,opset:{type:"path",ops:r}}}function A(t,e,s,n,o,a,r,h,i){const c=t,l=e;let u=Math.abs(s/2),f=Math.abs(n/2);u+=W(.01*u,i),f+=W(.01*f,i);let p=o,d=a;for(;p<0;)p+=2*Math.PI,d+=2*Math.PI;d-p>2*Math.PI&&(p=0,d=2*Math.PI);const g=2*Math.PI/i.curveStepCount,M=Math.min(g/2,(d-p)/2),k=F(M,c,l,u,f,p,d,1,i);if(!i.disableMultiStroke){const t=F(M,c,l,u,f,p,d,1.5,i);k.push(...t)}return r&&(h?k.push(...z(c,l,c+u*Math.cos(p),l+f*Math.sin(p),i),...z(c,l,c+u*Math.cos(d),l+f*Math.sin(d),i)):k.push({op:"lineTo",data:[c,l]},{op:"lineTo",data:[c+u*Math.cos(p),l+f*Math.sin(p)]})),{type:"path",ops:k}}function _(t,e){const s=[];if(t.length){const n=e.maxRandomnessOffset||0,o=t.length;if(o>2){s.push({op:"move",data:[t[0][0]+W(n,e),t[0][1]+W(n,e)]});for(let a=1;a<o;a++)s.push({op:"lineTo",data:[t[a][0]+W(n,e),t[a][1]+W(n,e)]})}}return{type:"fillPath",ops:s}}function C(t,e){return function(t,e){let s=t.fillStyle||"hachure";if(!d[s])switch(s){case"zigzag":d[s]||(d[s]=new c(e));break;case"cross-hatch":d[s]||(d[s]=new l(e));break;case"dots":d[s]||(d[s]=new u(e));break;case"dashed":d[s]||(d[s]=new f(e));break;case"zigzag-line":d[s]||(d[s]=new p(e));break;case"hachure":default:s="hachure",d[s]||(d[s]=new i(e))}return d[s]}(e,x).fillPolygon(t,e)}function D(t){return t.randomizer||(t.randomizer=new g(t.seed||0)),t.randomizer.next()}function E(t,e,s,n=1){return s.roughness*n*(D(s)*(e-t)+t)}function W(t,e,s=1){return E(-t,t,e,s)}function z(t,e,s,n,o,a=!1){const r=a?o.disableMultiStrokeFill:o.disableMultiStroke,h=R(t,e,s,n,o,!0,!1);if(r)return h;const i=R(t,e,s,n,o,!0,!0);return h.concat(i)}function R(t,e,s,n,o,a,r){const h=Math.pow(t-s,2)+Math.pow(e-n,2),i=Math.sqrt(h);let c=1;c=i<200?1:i>500?.4:-.0016668*i+1.233334;let l=o.maxRandomnessOffset||0;l*l*100>h&&(l=i/10);const u=l/2,f=.2+.2*D(o);let p=o.bowing*o.maxRandomnessOffset*(n-e)/200,d=o.bowing*o.maxRandomnessOffset*(t-s)/200;p=W(p,o,c),d=W(d,o,c);const g=[],M=()=>W(u,o,c),k=()=>W(l,o,c);return a&&(r?g.push({op:"move",data:[t+M(),e+M()]}):g.push({op:"move",data:[t+W(l,o,c),e+W(l,o,c)]})),r?g.push({op:"bcurveTo",data:[p+t+(s-t)*f+M(),d+e+(n-e)*f+M(),p+t+2*(s-t)*f+M(),d+e+2*(n-e)*f+M(),s+M(),n+M()]}):g.push({op:"bcurveTo",data:[p+t+(s-t)*f+k(),d+e+(n-e)*f+k(),p+t+2*(s-t)*f+k(),d+e+2*(n-e)*f+k(),s+k(),n+k()]}),g}function $(t,e,s){const n=[];n.push([t[0][0]+W(e,s),t[0][1]+W(e,s)]),n.push([t[0][0]+W(e,s),t[0][1]+W(e,s)]);for(let o=1;o<t.length;o++)n.push([t[o][0]+W(e,s),t[o][1]+W(e,s)]),o===t.length-1&&n.push([t[o][0]+W(e,s),t[o][1]+W(e,s)]);return G(n,null,s)}function G(t,e,s){const n=t.length,o=[];if(n>3){const a=[],r=1-s.curveTightness;o.push({op:"move",data:[t[1][0],t[1][1]]});for(let e=1;e+2<n;e++){const s=t[e];a[0]=[s[0],s[1]],a[1]=[s[0]+(r*t[e+1][0]-r*t[e-1][0])/6,s[1]+(r*t[e+1][1]-r*t[e-1][1])/6],a[2]=[t[e+1][0]+(r*t[e][0]-r*t[e+2][0])/6,t[e+1][1]+(r*t[e][1]-r*t[e+2][1])/6],a[3]=[t[e+1][0],t[e+1][1]],o.push({op:"bcurveTo",data:[a[1][0],a[1][1],a[2][0],a[2][1],a[3][0],a[3][1]]})}if(e&&2===e.length){const t=s.maxRandomnessOffset;o.push({op:"lineTo",data:[e[0]+W(t,s),e[1]+W(t,s)]})}}else 3===n?(o.push({op:"move",data:[t[1][0],t[1][1]]}),o.push({op:"bcurveTo",data:[t[1][0],t[1][1],t[2][0],t[2][1],t[2][0],t[2][1]]})):2===n&&o.push(...z(t[0][0],t[0][1],t[1][0],t[1][1],s));return o}function q(t,e,s,n,o,a,r,h){const i=[],c=[],l=W(.5,h)-Math.PI/2;c.push([W(a,h)+e+.9*n*Math.cos(l-t),W(a,h)+s+.9*o*Math.sin(l-t)]);for(let r=l;r<2*Math.PI+l-.01;r+=t){const t=[W(a,h)+e+n*Math.cos(r),W(a,h)+s+o*Math.sin(r)];i.push(t),c.push(t)}return c.push([W(a,h)+e+n*Math.cos(l+2*Math.PI+.5*r),W(a,h)+s+o*Math.sin(l+2*Math.PI+.5*r)]),c.push([W(a,h)+e+.98*n*Math.cos(l+r),W(a,h)+s+.98*o*Math.sin(l+r)]),c.push([W(a,h)+e+.9*n*Math.cos(l+.5*r),W(a,h)+s+.9*o*Math.sin(l+.5*r)]),[c,i]}function F(t,e,s,n,o,a,r,h,i){const c=a+W(.1,i),l=[];l.push([W(h,i)+e+.9*n*Math.cos(c-t),W(h,i)+s+.9*o*Math.sin(c-t)]);for(let a=c;a<=r;a+=t)l.push([W(h,i)+e+n*Math.cos(a),W(h,i)+s+o*Math.sin(a)]);return l.push([e+n*Math.cos(r),s+o*Math.sin(r)]),l.push([e+n*Math.cos(r),s+o*Math.sin(r)]),G(l,null,i)}function j(t,e,s,n,o,a,r,h){const i=[],c=[h.maxRandomnessOffset||1,(h.maxRandomnessOffset||1)+.3];let l=[0,0];const u=h.disableMultiStroke?1:2;for(let f=0;f<u;f++)0===f?i.push({op:"move",data:[r[0],r[1]]}):i.push({op:"move",data:[r[0]+W(c[0],h),r[1]+W(c[0],h)]}),l=[o+W(c[f],h),a+W(c[f],h)],i.push({op:"bcurveTo",data:[t+W(c[f],h),e+W(c[f],h),s+W(c[f],h),n+W(c[f],h),l[0],l[1]]});return i}function N(t){return[...t]}function Z(t,e){return Math.pow(t[0]-e[0],2)+Math.pow(t[1]-e[1],2)}function Q(t,e,s){const n=Z(e,s);if(0===n)return Z(t,e);let o=((t[0]-e[0])*(s[0]-e[0])+(t[1]-e[1])*(s[1]-e[1]))/n;return o=Math.max(0,Math.min(1,o)),Z(t,H(e,s,o))}function H(t,e,s){return[t[0]+(e[0]-t[0])*s,t[1]+(e[1]-t[1])*s]}function V(t,e,s,n){const o=n||[];if(function(t,e){const s=t[e+0],n=t[e+1],o=t[e+2],a=t[e+3];let r=3*n[0]-2*s[0]-a[0];r*=r;let h=3*n[1]-2*s[1]-a[1];h*=h;let i=3*o[0]-2*a[0]-s[0];i*=i;let c=3*o[1]-2*a[1]-s[1];return c*=c,r<i&&(r=i),h<c&&(h=c),r+h}(t,e)<s){const s=t[e+0];if(o.length){(a=o[o.length-1],r=s,Math.sqrt(Z(a,r)))>1&&o.push(s)}else o.push(s);o.push(t[e+3])}else{const n=.5,a=t[e+0],r=t[e+1],h=t[e+2],i=t[e+3],c=H(a,r,n),l=H(r,h,n),u=H(h,i,n),f=H(c,l,n),p=H(l,u,n),d=H(f,p,n);V([a,c,f,d],0,s,o),V([d,p,u,i],0,s,o)}var a,r;return o}function B(t,e){return X(t,0,t.length,e)}function X(t,e,s,n,o){const a=o||[],r=t[e],h=t[s-1];let i=0,c=1;for(let n=e+1;n<s-1;++n){const e=Q(t[n],r,h);e>i&&(i=e,c=n)}return Math.sqrt(i)>n?(X(t,e,c+1,n,a),X(t,c,s,n,a)):(a.length||a.push(r),a.push(h)),a}function J(t,e=.15,s){const n=[],o=(t.length-1)/3;for(let s=0;s<o;s++){V(t,3*s,e,n)}return s&&s>0?X(n,0,n.length,s):n}const K="none"; class U{constructor(t){this.defaultOptions={maxRandomnessOffset:2,roughness:1,bowing:1,stroke:"#000",strokeWidth:1,curveTightness:0,curveFitting:.95,curveStepCount:9,fillStyle:"hachure",fillWeight:-1,hachureAngle:-41,hachureGap:-1,dashOffset:-1,dashGap:-1,zigzagOffset:-1,seed:0,combineNestedSvgPaths:!1,disableMultiStroke:!1,disableMultiStrokeFill:!1},this.config=t||{},this.config.options&&(this.defaultOptions=this._o(this.config.options))}static newSeed(){return Math.floor(Math.random()*2**31)}_o(t){return t?Object.assign({},this.defaultOptions,t):this.defaultOptions}_d(t,e,s){return{shape:t,sets:e||[],options:s||this.defaultOptions}}line(t,e,s,n,o){const a=this._o(o);return this._d("line",[v(t,e,s,n,a)],a)}rectangle(t,e,s,n,o){const a=this._o(o),r=[],h=S(t,e,s,n,a);if(a.fill){const o=[[t,e],[t+s,e],[t+s,e+n],[t,e+n]];"solid"===a.fillStyle?r.push(_(o,a)):r.push(C(o,a))}return a.stroke!==K&&r.push(h),this._d("rectangle",r,a)}ellipse(t,e,s,n,o){const a=this._o(o),r=[],h=T(s,n,a),i=I(t,e,a,h);if(a.fill)if("solid"===a.fillStyle){const s=I(t,e,a,h).opset;s.type="fillPath",r.push(s)}else r.push(C(i.estimatedPoints,a));return a.stroke!==K&&r.push(i.opset),this._d("ellipse",r,a)}circle(t,e,s,n){const o=this.ellipse(t,e,s,s,n);return o.shape="circle",o}linearPath(t,e){const s=this._o(e);return this._d("linearPath",[O(t,!1,s)],s)}arc(t,e,s,n,o,a,r=!1,h){const i=this._o(h),c=[],l=A(t,e,s,n,o,a,r,!0,i);if(r&&i.fill)if("solid"===i.fillStyle){const r=A(t,e,s,n,o,a,!0,!1,i);r.type="fillPath",c.push(r)}else c.push(function(t,e,s,n,o,a,r){const h=t,i=e;let c=Math.abs(s/2),l=Math.abs(n/2);c+=W(.01*c,r),l+=W(.01*l,r);let u=o,f=a;for(;u<0;)u+=2*Math.PI,f+=2*Math.PI;f-u>2*Math.PI&&(u=0,f=2*Math.PI);const p=(f-u)/r.curveStepCount,d=[];for(let t=u;t<=f;t+=p)d.push([h+c*Math.cos(t),i+l*Math.sin(t)]);return d.push([h+c*Math.cos(f),i+l*Math.sin(f)]),d.push([h,i]),C(d,r)}(t,e,s,n,o,a,i));return i.stroke!==K&&c.push(l),this._d("arc",c,i)}curve(t,e){const s=this._o(e),n=[],o=L(t,s);if(s.fill&&s.fill!==K&&t.length>=3){const e=J(function(t,e=0){const s=t.length;if(s<3)throw new Error("A curve must have at least three points.");const n=[];if(3===s)n.push(N(t[0]),N(t[1]),N(t[2]),N(t[2]));else{const s=[];s.push(t[0],t[0]);for(let e=1;e<t.length;e++)s.push(t[e]),e===t.length-1&&s.push(t[e]);const o=[],a=1-e;n.push(N(s[0]));for(let t=1;t+2<s.length;t++){const e=s[t];o[0]=[e[0],e[1]],o[1]=[e[0]+(a*s[t+1][0]-a*s[t-1][0])/6,e[1]+(a*s[t+1][1]-a*s[t-1][1])/6],o[2]=[s[t+1][0]+(a*s[t][0]-a*s[t+2][0])/6,s[t+1][1]+(a*s[t][1]-a*s[t+2][1])/6],o[3]=[s[t+1][0],s[t+1][1]],n.push(o[1],o[2],o[3])}}return n}(t),10,(1+s.roughness)/2);"solid"===s.fillStyle?n.push(_(e,s)):n.push(C(e,s))}return s.stroke!==K&&n.push(o),this._d("curve",n,s)}polygon(t,e){const s=this._o(e),n=[],o=O(t,!0,s);return s.fill&&("solid"===s.fillStyle?n.push(_(t,s)):n.push(C(t,s))),s.stroke!==K&&n.push(o),this._d("polygon",n,s)}path(t,e){const s=this._o(e),n=[];if(!t)return this._d("path",n,s);t=(t||"").replace(/\n/g," ").replace(/(-\s)/g,"-").replace("/(ss)/g"," ");const o=s.fill&&"transparent"!==s.fill&&s.fill!==K,a=s.stroke!==K,r=!!(s.simplification&&s.simplification<1),h=function(t,e,s){const n=m(y(b(t))),o=[];let a=[],r=[0,0],h=[];const i=()=>{h.length>=4&&a.push(...J(h,e)),h=[]},c=()=>{i(),a.length&&(o.push(a),a=[])};for(const{key:t,data:e}of n)switch(t){case"M":c(),r=[e[0],e[1]],a.push(r);break;case"L":i(),a.push([e[0],e[1]]);break;case"C":if(!h.length){const t=a.length?a[a.length-1]:r;h.push([t[0],t[1]])}h.push([e[0],e[1]]),h.push([e[2],e[3]]),h.push([e[4],e[5]]);break;case"Z":i(),a.push([r[0],r[1]])}if(c(),!s)return o;const l=[];for(const t of o){const e=B(t,s);e.length&&l.push(e)}return l}(t,1,r?4-4*s.simplification:(1+s.roughness)/2);if(o)if(s.combineNestedSvgPaths){const t=[];h.forEach(e=>t.push(...e)),"solid"===s.fillStyle?n.push(_(t,s)):n.push(C(t,s))}else h.forEach(t=>{"solid"===s.fillStyle?n.push(_(t,s)):n.push(C(t,s))});return a&&(r?h.forEach(t=>{n.push(O(t,!1,s))}):n.push(function(t,e){const s=m(y(b(t))),n=[];let o=[0,0],a=[0,0];for(const{key:t,data:r}of s)switch(t){case"M":{const t=1*(e.maxRandomnessOffset||0);n.push({op:"move",data:r.map(s=>s+W(t,e))}),a=[r[0],r[1]],o=[r[0],r[1]];break}case"L":n.push(...z(a[0],a[1],r[0],r[1],e)),a=[r[0],r[1]];break;case"C":{const[t,s,o,h,i,c]=r;n.push(...j(t,s,o,h,i,c,a,e)),a=[i,c];break}case"Z":n.push(...z(a[0],a[1],o[0],o[1],e)),a=[o[0],o[1]]}return{type:"path",ops:n}}(t,s))),this._d("path",n,s)}opsToPath(t){let e="";for(const s of t.ops){const t=s.data;switch(s.op){case"move":e+=`M${t[0]} ${t[1]} `;break;case"bcurveTo":e+=`C${t[0]} ${t[1]}, ${t[2]} ${t[3]}, ${t[4]} ${t[5]} `;break;case"lineTo":e+=`L${t[0]} ${t[1]} `}}return e.trim()}toPaths(t){const e=t.sets||[],s=t.options||this.defaultOptions,n=[];for(const t of e){let e=null;switch(t.type){case"path":e={d:this.opsToPath(t),stroke:s.stroke,strokeWidth:s.strokeWidth,fill:K};break;case"fillPath":e={d:this.opsToPath(t),stroke:K,strokeWidth:0,fill:s.fill||K};break;case"fillSketch":e=this.fillSketch(t,s)}e&&n.push(e)}return n}fillSketch(t,e){let s=e.fillWeight;return s<0&&(s=e.strokeWidth/2),{d:this.opsToPath(t),stroke:e.fill||K,strokeWidth:s,fill:K}}} class Y{constructor(t,e){this.canvas=t,this.ctx=this.canvas.getContext("2d"),this.gen=new U(e)}draw(t){const e=t.sets||[],s=t.options||this.getDefaultOptions(),n=this.ctx;for(const o of e)switch(o.type){case"path":n.save(),n.strokeStyle="none"===s.stroke?"transparent":s.stroke,n.lineWidth=s.strokeWidth,s.strokeLineDash&&n.setLineDash(s.strokeLineDash),s.strokeLineDashOffset&&(n.lineDashOffset=s.strokeLineDashOffset),this._drawToContext(n,o),n.restore();break;case"fillPath":n.save(),n.fillStyle=s.fill||"";const e="curve"===t.shape||"polygon"===t.shape?"evenodd":"nonzero";this._drawToContext(n,o,e),n.restore();break;case"fillSketch":this.fillSketch(n,o,s)}}fillSketch(t,e,s){let n=s.fillWeight;n<0&&(n=s.strokeWidth/2),t.save(),s.fillLineDash&&t.setLineDash(s.fillLineDash),s.fillLineDashOffset&&(t.lineDashOffset=s.fillLineDashOffset),t.strokeStyle=s.fill||"",t.lineWidth=n,this._drawToContext(t,e),t.restore()}_drawToContext(t,e,s="nonzero"){t.beginPath();for(const s of e.ops){const e=s.data;switch(s.op){case"move":t.moveTo(e[0],e[1]);break;case"bcurveTo":t.bezierCurveTo(e[0],e[1],e[2],e[3],e[4],e[5]);break;case"lineTo":t.lineTo(e[0],e[1])}}"fillPath"===e.type?t.fill(s):t.stroke()}get generator(){return this.gen}getDefaultOptions(){return this.gen.defaultOptions}line(t,e,s,n,o){const a=this.gen.line(t,e,s,n,o);return this.draw(a),a}rectangle(t,e,s,n,o){const a=this.gen.rectangle(t,e,s,n,o);return this.draw(a),a}ellipse(t,e,s,n,o){const a=this.gen.ellipse(t,e,s,n,o);return this.draw(a),a}circle(t,e,s,n){const o=this.gen.circle(t,e,s,n);return this.draw(o),o}linearPath(t,e){const s=this.gen.linearPath(t,e);return this.draw(s),s}polygon(t,e){const s=this.gen.polygon(t,e);return this.draw(s),s}arc(t,e,s,n,o,a,r=!1,h){const i=this.gen.arc(t,e,s,n,o,a,r,h);return this.draw(i),i}curve(t,e){const s=this.gen.curve(t,e);return this.draw(s),s}path(t,e){const s=this.gen.path(t,e);return this.draw(s),s}}return{canvas:(t,e)=>new Y(t,e),svg:(t,e)=>new et(t,e),generator:t=>new U(t),newSeed:()=>U.newSeed()}}(); </script>
    
    <script>zzfxV=.15; zzfx=(q=1,k=.05,c=220,e=0,t=0,u=.1,r=0,F=1,v=0,z=0,w=0,A=0,l=0,B=0,x=0,G=0,d=0,y=1,m=0,C=0)=>{let b=2*Math.PI,H=v*=500*b/zzfxR**2,I=(0<x?1:-1)*b/4,D=c*=(1+2*k*Math.random()-k)*b/zzfxR,Z=[],g=0,E=0,a=0,n=1,J=0,K=0,f=0,p,h;e=99+zzfxR*e;m*=zzfxR;t*=zzfxR;u*=zzfxR;d*=zzfxR;z*=500*b/zzfxR**3;x*=b/zzfxR;w*=b/zzfxR;A*=zzfxR;l=zzfxR*l|0;for(h=e+m+t+u+d|0;a<h;Z[a++]=f)++K%(100*G|0)||(f=r?1<r?2<r?3<r?Math.sin((g%b)**3):Math.max(Math.min(Math.tan(g),1),-1):1-(2*g/b%2+2)%2:1-4*Math.abs(Math.round(g/b)-g/b):Math.sin(g),f=(l?1-C+C*Math.sin(2*Math.PI*a/l):1)*(0<f?1:-1)*Math.abs(f)**F*q*zzfxV*(a<e?a/e:a<e+m?1-(a-e)/m*(1-y):a<e+m+t?y:a<h-d?(h-a-d)/u*y:0),f=d?f/2+(d>a?0:(a<h-d?1:(h-a)/d)*Z[a-d|0]/2):f),p=(c+=v+=z)*Math.sin(E*x-I),g+=p-p*B*(1-1E9*(Math.sin(a)+1)%2),E+=p-p*B*(1-1E9*(Math.sin(a)**2+1)%2),n&&++n>A&&(c+=w,D+=w,n=0),!l||++J%l||(c=D,v=H,n=n||1);q=zzfxX.createBuffer(1,h,zzfxR);q.getChannelData(0).set(Z);c=zzfxX.createBufferSource();c.buffer=q;c.connect(zzfxX.destination);c.start();return c};zzfxX=new(window.AudioContext||webkitAudioContext);zzfxR=44100</script>
    <!--<script src="astar.js"></script>--><link rel="icon" type="image/ico"><meta property="og:title" content="Edge Not Found" /><meta property="og:description" content="Edge Not Found is a Sokoban-style puzzle game set on an infinitely repeating grid. Push the boxes to the targets in ~20 puzzles." /></head><body><noscript>Please enable Javascript to play this game!</noscript><canvas id="canvas" width="500" height="500"> </canvas>
    <script>var levels = []; levels.push([ {gates: [1, 3, 6, 12, 15], levelSpread: [1, 5, 10, 17], yOff: -2},"##########.", "p1g.1.1.1.g", "##########.", "2.2.2.2.2.g", "##########.", ".333.3333.g", "##########.", "4.4.4.4g4#." ]); levels.push([ {nr: 100, name: "A Wrapping World"},"#####.#", "......#", "...#..#", "#.###.#", ".b#t.p.", "..###.#", ]); levels.push([{nr: 101, name: "Infinite Inlet"}, "..#.", "p.#.", ".tbt", "#b.b", ".tbt", ]); levels.push([ {nr: 102, name: "Glass Hallway"},"##.##", ".t.tp", "bb#bb", ".t.t.", "##.##" ]); levels.push([ {nr: 103, name: "Girded Grid"},".#.#.#", "t.b.t.", ".#.#.#", "b.p.b.", ".#.#.#", "t.b.t." ]); levels.push([ {nr: 200, name: "Wrap Around The Block", yOff: 2},"....", "####", "....", "####", "..b.", "####", "t#.p", "####" ]); levels.push([ {nr: 201, name: "Crowned Conundrum", xOff: 3},"pb...b", "b#.#.#", ".#ttt#", ]); levels.push([ {nr: 202, name: "Twisted Terrace", xOff: 3},"b..p..", ".##.##", ".#.t.#", "bbt#tb", ".#.t.#", ".##.##" ]); levels.push([ {nr: 203, name: "Continuous Corridor", yOff: 3},"######", "tb..p.", "t....b", "######", "t#...b", "tb...#" ]); levels.push([ {nr: 204, name: "Grandiose Garden", yOff: 3},"..bpb.", "..#.#.", ".#.t.#", ".bt.tb", ".#.t.#", "..#.#." ]); levels.push([ {nr: 300, name: "Sift & Shift"},"bt##|#", "###p..", "####.#" ]); levels.push([ {nr: 301, name: "Cornered Contraption", yOff: 1},"p....", ".|...", "#####", ".t#..", "###.." ]); levels.push([ {nr: 302, name: "Zealous Zigzag"},"#t#t#t", ".-..-.", "###..#", ".p####", ".-....", ]); levels.push([ {nr: 303, name: "Irregular Infrastructure", yOff: 2},"##.|.", ".#..p", ".#..#", ".#.#t", "....#", "....." ]); levels.push([ {nr: 304, name: "Enchanted Encagement"},"##.#.###.#.#", "#..-..#....#", "#..p..#.t.t.", "#..-..##....", "##.#.###.#.#", ]); levels.push([ {nr: 305, name: "Riddle Raster", yOff: -1},"...", ".t.", "#|#", ".t.", "#b#", "pt.", "#|#", ]); levels.push([ {nr: 306, name: "Locked Loungerooms", yOff: -2},"#########", "####..###", ".......##", "####....#", "####.....", "....#...#", "#....#...", "...||.###", "##.p.....", "tt#...###", ]); levels.push([ {nr: 400, name: "Rubble Rundown"},"rrr#..r#", ".pb...r#", "#t######" ]); levels.push([ {nr: 401, name: "Quality Questions", yOff: -2},"rrrrrrr", "#t|#|t#", "#|t#t|#", "rrrprrr", "#######", "rrrrrrr", "#t#|#t#", "#|#t#|#", "rrrrrrr", "#######", ]); levels.push([ {nr: 402, name: "Swirling Stars"}, "....#r+tr", "b##..r.rb", "b.##..r.b", "..t...p..", "#ttt#rrr#", ]); levels.push([ {nr: 403, name: "Box Breakout"},"b.#.#.b", ".#rpr#.", "#rrtrr#", "...+...", "#rrtrr#", "q#r.r#q","bq#.#.b", ]); levels.push([ {nr: 404, name: "Edge Not Found", autoX: 1}, "...........", "#.#.###.#.#", "#p#.#.#.#t#", "###.#.#.###", "..#.###...#", ]);</script>
    
    <script>var scale = 70; var roughSeed = 1;const timing = new Timing((1/ 10), (1 / 60));const canvas = document.getElementById("canvas"); const ctx = canvas.getContext("2d", { alpha: false }); const roughCanvas = rough.canvas(canvas);const levelCanvas = document.createElement("canvas"); const levelCtx = levelCanvas.getContext("2d"); const roughLevel = rough.canvas(levelCanvas);const wallCanvas = document.createElement("canvas"); const wallCtx = wallCanvas.getContext("2d"); const roughWall = rough.canvas(wallCanvas); const wallMargin = 10;const playerCanvas = document.createElement("canvas"); const PlayerCtx = playerCanvas.getContext("2d"); const roughPlayer = rough.canvas(playerCanvas);const boxCanvas = document.createElement("canvas"); const boxCtx = boxCanvas.getContext("2d"); const roughBox = rough.canvas(boxCanvas); const boxMargin = 10;const targetCanvas = document.createElement("canvas"); const targetCtx = targetCanvas.getContext("2d"); const roughTarget = rough.canvas(targetCanvas); const targetMargin = 15;const rubbleCanvas = document.createElement("canvas"); const rubbleCtx = rubbleCanvas.getContext("2d"); const roughRubble = rough.canvas(rubbleCanvas); const rubbleMargin = 15;let undoStack = [];var camShakeX = 0; var camShakeY = 0;var gameName = "Edge Not Found "; var subTitle = "Press any key";const obj = { EMPTY: ".", PLAYER: "p", WALL: "#", BOX: "b", SHIFTBOX: "+", SHIFTBOXHOR: "-", SHIFTBOXVER: "|", TARGET: "t", LEVELONE: "1", LEVELTWO: "2", LEVELTHREE: "3", LEVELFOUR: "4", RUBBLE: "r", GATE: "g", }; var levelName = ""; var levelOffsetX = 0; var levelOffsetY = 0; var autoScrollX = 0;var autoScrollY = 0;var prevLevelOffsetX = 0;var prevLevelOffsetY = 0;onkeydown = function(e) { if (e.key == "ArrowDown" || e.key == "ArrowUp" || e.key == " " || e.key == "Backspace") { e.preventDefault(); }input(e); };window.onbeforeunload = function(e) { return "Quit?"; };var favicon = null; var wroteFavicon = false; onload = function(e) { favicon = document.querySelector('link[rel="icon"]'); };var level = 0; var gridHeight = levels[level].length; var gridWidth = levels[level][0].length;var player = {x: 0, y: 0};var walls = []; var boxes = []; var targets = []; var levelNodes = []; var gates = []; var rubble = [];var steps = ""; var prevHorDelta = 0; var prevVerDelta = 0;var timeSinceLastAction = 0;var timeToCompleteTween = 0.1; var timeToUpdateRenders = (1/3);var timeSinceUpdatedRenders = timeToUpdateRenders; var timeUntilLevelEnd = 4;var timeUntilLevelSelected = 1; var timeSinceLevelWon = timeUntilLevelEnd;var timeSinceLevelStart = 0; var timeToLoadLevel = 1; var timeUntilChangableTheme = 0.2; var timeSinceLastThemeChange = 0;var timeUntilPlayableAudio = 0.075; var timeSinceLastAudio = 0;var timeToDisplayLevelName = 0.2; var timeSinceLevelNameChanged = 0;var timeToToggleMenu = 0.25; var timeSinceMenuToggled = timeToToggleMenu;var menuOpened = false; var menuSelection = 0; var titleScreen = true;var verticalInput = new InputHandler(["KeyS", "ArrowDown"], ["KeyW", "ArrowUp"], timing, 0.1, 0.2); var horizontalInput = new InputHandler(["KeyD", "ArrowRight"], ["KeyA", "ArrowLeft"], timing, 0.1, 0.2); var undoInput = new InputHandler(["KeyZ", "Backspace"], [], timing, 0.1, 0.2); var confirmInput = new InputHandler(["KeyX", "Space", "Enter"], [], timing, 0.1, 0.2);var reduceMotion = false; var colors = []; colors[0] = ["Sketchbook", "#ffffff", "#000000", "#808080", "#ff0000"];colors[1] = ["Scratchpad", "#202020", "#ffffff", "#808080", "#ffd700"]; colors[2] = ["Golden Ticket", "#303030", "#b29700", "#8e7900", "#efe7d6"]; colors[3] = ["Ikaniko", "#1E2A26", "#7CA49B", "#267B75", "#C8EEE5"]; colors[4] = ["BackFlipped", "#223e32", "#b3dd52", "#04bf00", "#A7C06D"]; var colorTheme = 0; var audioEnabled = true;var freshState = true;var victory = false;var targetLevel = 0;var dirtyRender = true;var previousScale = 0;window.onresize = function() { canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; dirtyRender = true; };canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight;var levelSolved = []; for(var i = 0; i != levels.length; i += 1) { levelSolved[i] = 0;} var amountOfLevelsSolved = 0;loadGame();loadLevel(level);function gameLoop() { try {timing.update(); horizontalInput.update(); verticalInput.update(); undoInput.update(); confirmInput.update(); if (!victory && !titleScreen) { if (!menuOpened) { if (verticalInput.fired) { MovePlayer(0, verticalInput.delta); } if (horizontalInput.fired) { MovePlayer(horizontalInput.delta, 0); } if (undoInput.fired == true && undoStack.length != 0) { audio("undo");var stateToRestore = undoStack.pop();player = stateToRestore.player; boxes = stateToRestore.boxes; levelOffsetX = stateToRestore.xOff; levelOffsetY = stateToRestore.yOff;steps = steps.slice(0, -1); if (steps.length == 0 || steps.slice(-1) == " ") { freshState = true; } else { freshState = false; }if (level == 0) { var lvl = hasLevelNode(player.x, player.y); setLevelName(lvl,1); };timeSinceLastAction = timeToCompleteTween;console.warn("Popped the undo stack, remaining entries:", undoStack.length);dirtyRender = true; } if (confirmInput.fired) { if (timeSinceLevelStart >= timeToLoadLevel) { var lvl = hasLevelNode(player.x, player.y); if (lvl != null) { targetLevel = levelNodes[lvl].target; victory = true; timeSinceLevelWon = 0; audio("select"); } } } } else { var items = 5; if (level == 0) { items = 4; }if (verticalInput.fired && verticalInput.delta == 1) { menuSelection += 1; if (menuSelection >= items) {menuSelection = 0;} } else if (verticalInput.fired && verticalInput.delta == -1) { menuSelection -= 1; if (menuSelection < 0) {menuSelection = items-1;} } else if (confirmInput.fired) { switch(menuSelection) { case 0:menuOpened = !menuOpened; audio("select", true); break; case 1: audioEnabled = !audioEnabled; if (audioEnabled) { audio("menu", true); } saveGame(); break; case 2: reduceMotion = !reduceMotion; audio("walk", true); saveGame(); break; case 3: if (timeSinceLastThemeChange >= timeUntilChangableTheme) { timeSinceLastThemeChange = 0; colorTheme++; if (colorTheme >= colors.length) { colorTheme = 0; } dirtyRender = true; audio("walk", true); } saveGame(); break; case 4: loadLevel(0); audio("back", true); menuOpened = !menuOpened; } } } } timeSinceLastAction = Math.min(timeSinceLastAction + timing.currentFrameLength, timeToCompleteTween); timeSinceUpdatedRenders = Math.min(timeSinceUpdatedRenders + timing.currentFrameLength, timeToUpdateRenders); timeSinceLevelStart = Math.min(timeSinceLevelStart + timing.currentFrameLength, timeToLoadLevel); timeSinceLevelWon = Math.min(timeSinceLevelWon + timing.currentFrameLength, timeUntilLevelEnd);timeSinceLastThemeChange = Math.min(timeSinceLastThemeChange + timing.currentFrameLength, timeUntilChangableTheme); timeSinceLastAudio = Math.min(timeSinceLastAudio + timing.currentFrameLength, timeUntilPlayableAudio); timeSinceLevelNameChanged = Math.min(timeSinceLevelNameChanged + timing.currentFrameLength, timeToDisplayLevelName); timeSinceMenuToggled = Math.min(timeSinceMenuToggled + timing.currentFrameLength, timeToToggleMenu);if (titleScreen) { timeSinceLevelStart = timeToLoadLevel * .5; }if (canvas.width < 700 || canvas.height < 700) { scale = 40; } else if (canvas.width < 1000 || canvas.height < 900) { scale = 55; } else { scale = 70; }var alph = 1; var localScale = scale; if (timeSinceLevelStart < timeToLoadLevel) { alph = timeSinceLevelStart / timeToLoadLevel; localScale = (scale + 20) - 20 * EaseInOut(timeSinceLevelStart / timeToLoadLevel); } else if (timeSinceLevelWon < timeUntilLevelEnd && level != 0) { alph = 1 - (timeSinceLevelWon / timeUntilLevelEnd); localScale = (scale - 50) + 50 * (1-EaseInOut(timeSinceLevelWon / timeUntilLevelEnd)); } else if (timeSinceLevelWon < timeUntilLevelSelected && level == 0) { alph = 1 - (timeSinceLevelWon / timeUntilLevelSelected); localScale = (scale) - 20 * (EaseInOut(timeSinceLevelWon / timeUntilLevelSelected)); } else if (((timeSinceLevelWon >= timeUntilLevelEnd && level != 0) || (timeSinceLevelWon >= timeUntilLevelSelected && level == 0)) && victory) { if (level == 0) { loadLevel(targetLevel); } else { if (level == levels.length-1) { gameName = "Victory! "; subTitle = "Thank you for playing!"; titleScreen = true; audio("gameend"); } loadLevel(0); } alph = 0; }if (reduceMotion) { var localScale = scale; }var verHeight = gridHeight * localScale; var horWidth = gridWidth * localScale; var rerendered = false; if ((!reduceMotion && timeSinceUpdatedRenders >= timeToUpdateRenders) || localScale != previousScale || dirtyRender) { if (!reduceMotion && timeSinceUpdatedRenders >= timeToUpdateRenders) { roughSeed += 1; timeSinceUpdatedRenders = 0; }rerendered = true; dirtyRender = false;if (localScale != previousScale) { playerCanvas.width = localScale; playerCanvas.height = localScale;wallCanvas.width = localScale+wallMargin; wallCanvas.height = localScale+wallMargin;boxCanvas.width = localScale+boxMargin; boxCanvas.height = localScale+boxMargin;rubbleCanvas.width = localScale+rubbleMargin; rubbleCanvas.height = localScale+rubbleMargin;targetCanvas.width = localScale+targetMargin; targetCanvas.height = localScale+targetMargin; } else { PlayerCtx.clearRect(0,0, playerCanvas.width, playerCanvas.height); PlayerCtx.beginPath();wallCtx.clearRect(0,0, wallCanvas.width, wallCanvas.height); wallCtx.beginPath();boxCtx.clearRect(0,0, boxCanvas.width, boxCanvas.height); boxCtx.beginPath();rubbleCtx.clearRect(0,0, rubbleCanvas.width, rubbleCanvas.height); rubbleCtx.beginPath();targetCtx.clearRect(0,0, targetCanvas.width, targetCanvas.height); targetCtx.beginPath(); } var size = 0.8; roughPlayer.circle(localScale * .5, localScale * .5, localScale * size, {fill: colors[colorTheme][1], fillStyle: "solid", stroke: colors[colorTheme][2], strokeWidth: 1, seed: roughSeed}); roughWall.rectangle(wallMargin * 0.5, wallMargin * 0.5,localScale, localScale, {stroke: colors[colorTheme][2], fill: colors[colorTheme][2], strokeWidth: 1, seed: roughSeed}); var size = 0.8; roughBox.rectangle(boxMargin * 0.5 + (1-size) * 0.5 * localScale, boxMargin * 0.5 + (1-size) * 0.5 * localScale,localScale * size, localScale * size, {stroke: colors[colorTheme][2], fill: colors[colorTheme][2], strokeWidth: 2, seed: roughSeed}); var size = 1.1; roughRubble.rectangle(rubbleMargin * 0.5 + (1-size) * 0.5 * localScale, rubbleMargin * 0.5 + (1-size) * 0.5 * localScale,localScale * size, localScale * size, {stroke: "none", fill: colors[colorTheme][2], fillStyle: "dots", fillWeight: localScale / 70, strokeWidth: 2, seed: roughSeed}); var size = 1.1; roughTarget.circle(localScale * 0.5 + targetMargin * 0.5, localScale * 0.5 + targetMargin * 0.5,localScale * size, {fillStyle: "zigzag", fill: colors[colorTheme][3], stroke: colors[colorTheme][2], strokeWidth: 1, seed: roughSeed}); }if (favicon != null && !wroteFavicon) { favicon.href = targetCanvas.toDataURL('image/png'); wroteFavicon = true;}var shaking = (camShakeX != 0 || camShakeY != 0); var reduceCamShake = 2; if (camShakeX > 0) {camShakeX = Math.max(0, camShakeX - reduceCamShake)} else if (camShakeX < 0) {camShakeX = Math.min(0, camShakeX + reduceCamShake)}if (camShakeY > 0) {camShakeY = Math.max(0, camShakeY - reduceCamShake)} else if (camShakeY < 0) {camShakeY = Math.min(0, camShakeY + reduceCamShake)}var levelMargin = 20;if (rerendered || timeSinceUpdatedRenders >= timeToUpdateRenders || timeSinceLastAction <= timeToCompleteTween * 2 || alph != 1 || shaking) {if (localScale != previousScale || dirtyRender) { levelCanvas.width = horWidth+levelMargin; levelCanvas.height = verHeight+levelMargin; } else { levelCtx.clearRect(0,0, levelCanvas.width, levelCanvas.height); levelCtx.beginPath(); }drawLevel(0, 0, gridWidth, gridHeight, localScale);rerendered = true; }if (rerendered || titleScreen) { var shakeMultiplier = 1; if (reduceMotion) {shakeMultiplier = 0}var cameraX = Math.round(canvas.width * 0.5 - horWidth * 0.5 - levelMargin * 0.5 + camShakeX * 0.25 * shakeMultiplier); var cameraY = Math.round(canvas.height * 0.5 - verHeight * 0.5 - levelMargin * 0.5+ camShakeY * 0.25 * shakeMultiplier);var clipOffset = 10;var screenWidthRatio = Math.ceil(((canvas.width - horWidth + clipOffset) / horWidth * 0.5)); var screenHeightRatio = Math.ceil(((canvas.height - verHeight + clipOffset) / verHeight * 0.5)); if (levelOffsetX != 0) {screenWidthRatio += 1} if (levelOffsetY != 0) {screenHeightRatio += 1}var tweenOffsetX = levelOffsetX - prevLevelOffsetX * (1-EaseInOut(Math.min(timeSinceLastAction / timeToCompleteTween, 1))); var tweenOffsetY = levelOffsetY - prevLevelOffsetY * (1-EaseInOut(Math.min(timeSinceLastAction / timeToCompleteTween, 1)));ctx.globalAlpha = 1; ctx.fillStyle = colors[colorTheme][1]; ctx.fillRect(0,0,canvas.width, canvas.height);for(let y = -screenHeightRatio; y <= screenHeightRatio; y++) { for(let x = -screenWidthRatio; x <= screenWidthRatio; x++) { if (x != 0 || y != 0){ ctx.globalAlpha = Math.max(0, alph - Math.abs(y) * 0.1 - Math.abs(x * 0.1)); if (ctx.globalAlpha > 0) { ctx.drawImage(levelCanvas,cameraX + horWidth * x + tweenOffsetX * localScale * y, cameraY + verHeight * y + tweenOffsetY * localScale * x); } } } }ctx.globalAlpha = alph; ctx.drawImage(levelCanvas, Math.round(cameraX + camShakeX * shakeMultiplier), Math.round(cameraY + camShakeY * shakeMultiplier)); const borderOffset = 5; roughCanvas.rectangle(Math.round(cameraX-borderOffset + camShakeX * 0.5 * shakeMultiplier), Math.round(cameraY-borderOffset + camShakeY * 0.5 * shakeMultiplier),horWidth + borderOffset + levelMargin, verHeight + borderOffset + levelMargin, {stroke: colors[colorTheme][2], seed: roughSeed}); ctx.globalAlpha = 1; if (titleScreen || menuOpened) {ctx.globalAlpha = 0.4; ctx.fillStyle = colors[colorTheme][1]; ctx.fillRect(-1,-1,canvas.width + 2, canvas.height + 2); ctx.globalAlpha = 1; } if (!titleScreen) { ctx.textAlign = "left"; ctx.font = "40px sans-serif"; ctx.globalAlpha = EaseInOut(timeSinceLevelNameChanged / timeToDisplayLevelName); drawStroked(ctx, levelName, 40, canvas.height - 40); ctx.globalAlpha = 1; }ctx.font = "22px sans-serif"; ctx.fillStyle = colors[colorTheme][1]; ctx.textAlign = "center"; ctx.textBaseline = "middle"; if (titleScreen) { ctx.font = Math.round(scale * 1.2) + "px sans-serif"; ctx.textAlign = "left"; ctx.textBaseline = "center"; ctx.fillStyle = "black";var txt = gameName;var textWidth = ctx.measureText(txt).width; var amount = Math.ceil(canvas.width / textWidth)+1;txt = txt.repeat(amount);var startX = 0; if (!reduceMotion) { var startX = (timing.timePlaying % 5) / 5; }drawStroked(ctx, txt,-startX * textWidth,canvas.height * .5);ctx.font = Math.round(scale * 0.5) + "px sans-serif"; ctx.textAlign = "center"; drawStroked(ctx, subTitle,canvas.width * .5,canvas.height * .6); } else if (!menuOpened) { if (!victory) {roughCanvas.rectangle(-5, -5, 85, 85, {fill: colors[colorTheme][2], fillWeight: 4, stroke: "none", seed: Math.round(roughSeed / 2)}); ctx.fillText("[Esc]",50,60); if (level != 0) { if (!freshState) { ctx.globalAlpha = 1; } else { ctx.globalAlpha = 0.25; } roughCanvas.rectangle(canvas.width-160, canvas.height - 80, 100, 50, {fill: colors[colorTheme][2], fillWeight: 4, stroke: "none", seed: Math.round(roughSeed / 2)}); ctx.fillText("[R] Retry",canvas.width-110,canvas.height - 55);if (undoStack.length > 0) { ctx.globalAlpha = 1; } else { ctx.globalAlpha = 0.25; }roughCanvas.rectangle(canvas.width-280, canvas.height - 80, 100, 50, {fill: colors[colorTheme][2], fillWeight: 4, stroke: "none", seed: Math.round(roughSeed / 2) + 10}); ctx.fillText("[Z] Undo",canvas.width-230,canvas.height - 55); } } } else { ctx.globalAlpha = 1; var growth = 1; if (!reduceMotion) { var growth = EaseInOut(timeSinceMenuToggled / timeToToggleMenu); } var width = 400 * growth; roughCanvas.rectangle(-5, -5, width + 5, 55 + 250 * growth, {fill: colors[colorTheme][2], fillWeight: 4, stroke: "none", seed: Math.round(roughSeed / 2)});var textBase = 50; var textOffset = 50 * growth; ctx.globalAlpha = growth; roughCanvas.rectangle(20, textBase * 0.5 + menuSelection * textOffset, width - 40, textOffset, {fillStyle: "none", stroke: colors[colorTheme][1], seed: roughSeed});ctx.fillStyle = colors[colorTheme][1]; ctx.textAlign = "center";var txt = "Audio: "; if (audioEnabled == true) { txt += "ON"; } else { txt += "OFF"; } ctx.fillText(txt, width * 0.5,textBase + textOffset * 1);ctx.fillText("[Esc] Resume", width * 0.5,textBase); var txt = "Reduce Motion: "; if (reduceMotion == true) { txt += "ON"; } else { txt += "OFF"; } ctx.fillText(txt, width * 0.5,textBase + textOffset * 2);txt = "Theme: "+colors[colorTheme][0] + " ("+(colorTheme+1) + "/" + colors.length + ")"; ctx.fillText(txt, width * 0.5,textBase + textOffset * 3);if (level != 0) { ctx.fillText("Back to Level Select", width * 0.5, textBase + textOffset * 4 ); } else { ctx.font = "16px sans-serif"; ctx.fillText("Game by Tom Hermans for js13k 2020", width * 0.5, textBase + textOffset * 3.8); ctx.fillText("rough - Copyright (c) 2019 Preet Shihn", width * 0.5, textBase + textOffset * 4.2); ctx.fillText("ZzFX - Copyright (c) 2019 Frank Force", width * 0.5, textBase + textOffset * 4.6); }ctx.globalAlpha = 1; } }previousScale = localScale; window.requestAnimationFrame(gameLoop); } catch (e) { console.error("Whoops! The game crashed.", e); console.log("Please report this information to the dev. (It might contain some personal information.)"); console.log("Your user agent is:",navigator.userAgent); console.log("Are your cookies enabled?",navigator.cookieEnabled);const canvas = document.getElementById("canvas"); if (canvas) { console.log("Size of the canvas:",{width: canvas.width, height: canvas.height}); ctx.font = "30px sans-serif"; ctx.fillStyle = "red"; ctx.textAlign = "left"; ctx.fillText("Whoops, the game crashed! See the console for more info.",50,50); } } };window.requestAnimationFrame(gameLoop);function drawLevel(rootX,rootY, gridWidth, gridHeight, localScale) {function drawWrapped(object, drawFunction) { drawFunction(0,0);if (object.x <= 0.5) { var wrapY = ((object.y + levelOffsetY + gridHeight) % gridHeight) - object.y; drawFunction(gridWidth * localScale, wrapY * localScale); } else if (object.x >= gridWidth-1.5) { var wrapY = ((object.y - levelOffsetY + gridHeight) % gridHeight) - object.y; drawFunction(-gridWidth * localScale, wrapY * localScale); }if (object.y <= 0.5) { var wrapX = ((object.x + levelOffsetX + gridWidth) % gridWidth) - object.x; drawFunction(wrapX * localScale, gridHeight * localScale); } else if (object.y >= gridHeight-1.5) { var wrapX = ((object.x - levelOffsetX + gridWidth) % gridWidth) - object.x; drawFunction(wrapX * localScale, -gridHeight * localScale); } }var off = 10;var playerTween = tweenPlayer(); if (undoStack.length > 0 && !reduceMotion) { var amt = Clamp(undoStack.length, 1, 11); for(var i = 0; i < amt; i += 1) { var index = undoStack.length - amt + i;if (steps[index] == " " || index < 0 || index > undoStack.length) { break; }var percent = 1; if (index == undoStack.length-1) { percent = timeSinceLastAction / timeToCompleteTween; };var blend = Math.max(0, ((i + (1-percent)) / amt) * 0.25); var clr = blendColors(colors[colorTheme][1], colors[colorTheme][3],blend);var p1 = {x: undoStack[index].player.x, y: undoStack[index].player.y}; var p2 = {x: undoStack[index].player.x, y: undoStack[index].player.y}; switch (steps[index].toLowerCase()) { case "u": p1.y += 0.2; p2.y -= 1.2 * percent; break; case "d": p1.y -= 0.2; p2.y += 1.2 * percent; break; case "l": p1.x += 0.2; p2.x -= 1.2 * percent; break; case "r": p1.x += 0.2; p2.x += 1.2 * percent; break; }function drawLine(offsetX = 0, offsetY = 0) { roughLevel.line(PosX(p1.x + .5)+offsetX, PosY(p1.y + .5) +offsetY, PosX(p2.x + .5) +offsetX, PosY(p2.y + .5) +offsetY, {strokeWidth: localScale * 0.4, stroke: clr, seed: roughSeed+i, roughness: 0.75}); }drawWrapped(p1, drawLine); } } for(let i = 0; i != rubble.length; i++) {levelCtx.drawImage(rubbleCanvas, PosX(rubble[i].x) - rubbleMargin * 0.5, PosY(rubble[i].y) - rubbleMargin * 0.5); } for(let i = 0; i != targets.length; i++) { levelCtx.drawImage(targetCanvas, PosX(targets[i].x) - targetMargin * 0.5, PosY(targets[i].y) - targetMargin * 0.5); } for(let i = 0; i != gates.length; i++) { if (gates[i].target <= amountOfLevelsSolved) { levelCtx.globalAlpha = 0.2; } else { levelCtx.globalAlpha = 1; } levelCtx.drawImage(boxCanvas, PosX(gates[i].x) - boxMargin * 0.5, PosY(gates[i].y) - boxMargin * 0.5); } levelCtx.globalAlpha = 1; for(let i = 0; i != walls.length; i++) { levelCtx.drawImage(wallCanvas, PosX(walls[i].x) - wallMargin * 0.5, PosY(walls[i].y) - wallMargin * 0.5); } for(let i = 0; i != levelNodes.length; i++) { levelCtx.drawImage(targetCanvas, PosX(levelNodes[i].x) - targetMargin * 0.5, PosY(levelNodes[i].y) - targetMargin * 0.5); } function drawPlayer(offsetX = 0, offsetY = 0) { levelCtx.drawImage(playerCanvas, PosX(playerTween.x) + offsetX + camShakeX,PosY(playerTween.y) + offsetY + camShakeY); }drawWrapped(player, drawPlayer); for(let i = 0; i != boxes.length; i++) { var boxTween = tweenBox(i);function drawBox(offsetX = 0, offsetY = 0) { levelCtx.drawImage(boxCanvas, PosX(boxTween.x) - boxMargin * .5 + offsetX,PosY(boxTween.y) - boxMargin * 0.5 + offsetY); if (boxes[i].shift == 1 || boxes[i].shift == 3) { roughLevel.line(PosX(boxTween.x) + localScale * 0.2 + offsetX, PosY(boxTween.y) + localScale * 0.5 + offsetY,PosX(boxTween.x) + localScale * 0.8 + offsetX, PosY(boxTween.y) + localScale * 0.5 + offsetY,{stroke: colors[colorTheme][4], strokeWidth: localScale / 7, seed: roughSeed}) } if (boxes[i].shift == 2 || boxes[i].shift == 3) { roughLevel.line(PosX(boxTween.x) + localScale * 0.5 + offsetX, PosY(boxTween.y) + localScale * 0.2 + offsetY,PosX(boxTween.x) + localScale * 0.5 + offsetX, PosY(boxTween.y) + localScale * 0.8 + offsetY,{stroke: colors[colorTheme][4], strokeWidth: localScale / 7, seed: roughSeed}) } }drawWrapped(boxes[i], drawBox); } levelCtx.textAlign = "center"; levelCtx.textBaseline = "middle"; levelCtx.fillStyle = colors[colorTheme][2]; for(let i = 0; i != levelNodes.length; i++) {levelCtx.font = Math.round(0.5 * localScale)+"px sans-serif"; levelCtx.fillText(levels[levelNodes[i].target][0].nr.toString(), PosX(levelNodes[i].x) + targetCanvas.width * 0.5 - targetMargin * 0.5, PosY(levelNodes[i].y) - targetMargin * 0.5 + targetCanvas.height * 0.5);if (levelSolved[i+1] == 2) { levelCtx.font = Math.round(0.4 * localScale)+"px sans-serif"; levelCtx.fillText("‚úì", PosX(levelNodes[i].x) + targetCanvas.width * 0.75 - targetMargin * 0.5, PosY(levelNodes[i].y) - targetMargin * 0.5 + targetCanvas.height * 0.75); } else if (levelSolved[i+1] == 0) { levelCtx.font = "bold " + Math.round(0.25 * localScale)+"px sans-serif"; levelCtx.fillText("!", PosX(levelNodes[i].x) + targetCanvas.width * 0.5 - targetMargin * 0.5, PosY(levelNodes[i].y) - targetMargin * 0.5 + targetCanvas.height * 0.8); } } levelCtx.font = Math.round(0.4 * localScale)+"px sans-serif"; levelCtx.textAlign = "center"; levelCtx.textBaseline = "middle"; levelCtx.fillStyle = colors[colorTheme][2]; for(let i = 0; i != gates.length; i++) { if (gates[i].target <= amountOfLevelsSolved) { levelCtx.globalAlpha = 0.2; } else { levelCtx.globalAlpha = 1; } drawStroked(levelCtx, amountOfLevelsSolved + "/" + gates[i].target, PosX(gates[i].x) + boxCanvas.width * 0.5 - boxMargin * 0.5, PosY(gates[i].y) - boxMargin * 0.5 + boxCanvas.height * 0.5) } levelCtx.globalAlpha = 1;function tweenPlayer() { if (undoStack.length > 0) { var lastState = undoStack[undoStack.length-1]; var source = lastState.player; return tweenObject(player, source); } else { return({x: player.x, y: player.y}); } }function tweenBox(id) { if (undoStack.length > 0) { var lastState = undoStack[undoStack.length-1]; var source = lastState.boxes[id]; return tweenObject(boxes[id], source); } else { return({x: boxes[id].x, y: boxes[id].y}); } }function tweenObject(current, source) { var percent = 1-Clamp((timeSinceLastAction / timeToCompleteTween), 0, 1);if (percent != 0) { var diffX = Math.round(current.x - source.x); var diffY = Math.round(current.y - source.y); if (diffX != 0 && diffY != 0) { if (prevHorDelta != 0) {diffX -= Math.sign(diffX) * gridWidth; diffY = 0; } else { diffY -= Math.sign(diffY) * gridHeight; diffX = 0; } } else if (Math.abs(diffX) > 1) { diffX -= Math.sign(diffX) * gridWidth; } else if (Math.abs(diffY) > 1) { diffY -= Math.sign(diffY) * gridHeight; }percent = EaseInOut(percent);return ({x: current.x - (diffX * percent), y: current.y - (diffY * percent)}); } else { return({x: current.x, y: current.y}); } }function PosX(val) { return (rootX + off + val * localScale); }function PosY(val) { return (rootY + off + val * localScale); } }function input(event) { if (victory) {return;} if (titleScreen) { audio("select", true); titleScreen = false; return; }var key = event.key;dirtyRender = true;if (key == "Escape" && timeSinceMenuToggled >= 0.1) { menuOpened = !menuOpened; if (menuOpened) { audio("menu", true); } else { audio("select", true); } timeSinceMenuToggled = 0; menuSelection = 0; }if (!menuOpened) { if (key == "r" || key == "R") { if (!freshState) { audio("restart"); undoStack.push({player: player, boxes: boxes.slice(), xOff: levelOffsetX, yOff: levelOffsetY}); loadLevel(level, false); } return; } else if (event.shiftKey && key == "n" || key == "N") { loadLevel(Math.min(level + 1, levels.length-1 ));return; } else if (event.shiftKey && key == "b" || key == "B") { loadLevel(Math.max(level - 1, 0 ));return; } } }function loadLevel(number, resetStack = true) { level = number;var levelToLoad = levels[number].slice(); var metadata = levelToLoad.shift();gridHeight = levelToLoad.length; gridWidth = levelToLoad[0].length;if (levelSolved[level] == 0) { levelSolved[level] = 1; saveGame(); }player = {x: 0, y: 0}; walls.length = 0; boxes.length = 0; targets.length = 0; levelNodes.length = 0; rubble.length = 0; gates.length = 0;camShakeX = 0; camShakeY = 0;freshState = true;victory = false;setLevelName(level);if (levelSolved[level] == 2 && level != 0) { levelName += " ‚úì"; }if (metadata.xOff) { levelOffsetX = metadata.xOff; } else { levelOffsetX = 0; }if (metadata.yOff) { levelOffsetY = metadata.yOff; } else { levelOffsetY = 0; }if (metadata.autoX) { autoScrollX = metadata.autoX; } else { autoScrollX = 0; }if (metadata.autoY) { autoScrollY = metadata.autoX; } else { autoScrollY = 0; }var placedPlayer = false; var levelsPlaced = null; if (metadata.levelSpread) {var levelsPlaced = metadata.levelSpread.slice(); } var gatesPlaced = 0;function checkPlayer(x, y, lvl) { if (lvl == targetLevel && !placedPlayer) { this.player = {x: x, y: y}; placedPlayer = true;levelName = levels[targetLevel][0].nr+": "+levels[targetLevel][0].name + " - [Space] to enter"; timeSinceLevelNameChanged = 0; } }for(let y = 0; y < gridHeight; y++) { for(let x = 0; x < gridWidth; x++) { var str = levelToLoad[y].substring(x,x+1).toLowerCase(); switch (str) { case obj.PLAYER: if (!placedPlayer) { player = {x: x, y: y}; } break; case obj.WALL: walls.push({x: x, y: y}); break; case obj.BOX: boxes.push({x: x, y: y, shift: 0}); break; case obj.SHIFTBOXHOR: boxes.push({x: x, y: y, shift: 1}); break; case obj.SHIFTBOXVER: boxes.push({x: x, y: y, shift: 2}); break; case obj.SHIFTBOX: boxes.push({x: x, y: y, shift: 3}); break;case obj.TARGET: targets.push({x: x, y: y}); break; case obj.LEVELONE: levelNodes.push({x: x, y: y, target: levelsPlaced[0]});checkPlayer(x, y, levelsPlaced[0]); levelsPlaced[0]++; break; case obj.LEVELTWO: if (amountOfLevelsSolved < metadata.gates[1]) { targets.push({x: x, y: y}); break; } levelNodes.push({x: x, y: y, target: levelsPlaced[1]});checkPlayer(x, y, levelsPlaced[1]); levelsPlaced[1]++; break; case obj.LEVELTHREE: if (amountOfLevelsSolved < metadata.gates[2]) { targets.push({x: x, y: y}); break; } levelNodes.push({x: x, y: y, target: levelsPlaced[2]});checkPlayer(x, y, levelsPlaced[2]); levelsPlaced[2]++; break; case obj.LEVELFOUR: if (amountOfLevelsSolved < metadata.gates[3]) { targets.push({x: x, y: y}); break; } levelNodes.push({x: x, y: y, target: levelsPlaced[3]});checkPlayer(x, y, levelsPlaced[3]); levelsPlaced[3]++; break; case obj.RUBBLE: rubble.push({x: x, y: y}); break; case obj.GATE: gates.push({x: x, y: y, target: metadata.gates[gatesPlaced]}); gatesPlaced++; } } }if (resetStack) { undoStack = []; steps = ""; timeSinceLevelStart = 0; timeSinceLevelWon = timeUntilLevelEnd; } else { steps += " "; } }function wrapCoords(newX, newY) { function wrapX() { if (newX >= gridWidth) { newX -= gridWidth; newY -= levelOffsetY;return true; } else if (newX < 0) { newX += gridWidth; newY += levelOffsetY;return true; } return false; }function wrapY() { if (newY >= gridHeight) { newY -= gridHeight; newX -= levelOffsetX;return true; } else if (newY < 0) { newY += gridHeight; newX += levelOffsetX;return true; } return false; }var wrappedOnX = wrapX();wrapY(); if (!wrappedOnX) {wrapX(); } return {x: newX, y: newY} }function hasThing(array, x, y) {for(let i = 0; i != array.length; i++) { if (array[i].x == x && array[i].y == y) { return i; } } return null; }function hasWall(x, y) { return hasThing(walls, x, y) }function hasBox(x, y) { return hasThing(boxes, x, y) }function hasTarget(x, y) { return hasThing(targets, x, y) }function hasLevelNode(x, y) { return hasThing(levelNodes, x, y) }function hasRubble(x, y) { return hasThing(rubble, x, y) }function hasClosedGate(x, y) { var gate = hasThing(gates, x, y); if (gates[gate] != null) {if (gates[gate].target <= amountOfLevelsSolved) { return null; } } return gate; }function even(val) { return ((val % 2) == 0) }function EaseInOut(t) { return(t*(2-t)); } function drawStroked(ctx, text, x, y) { ctx.miterLimit = 2; ctx.strokeStyle = colors[colorTheme][2]; ctx.lineWidth = 8; ctx.strokeText(text, x, y); ctx.fillStyle = colors[colorTheme][1]; ctx.fillText(text, x, y); }function MovePlayer(horDelta, verDelta) { var dir = "";if (horDelta == -1) {dir = "l"} else if (horDelta == 1) {dir = "r"} else if (verDelta == 1) {dir = "d"} else if (verDelta == -1) {dir = "u"} else {throw new Error("MovePlayer function did not recieve valid arguments.")}if (horDelta != 0 || verDelta != 0) { undoStack.push({player: player, boxes: boxes.slice(), xOff: levelOffsetX, yOff: levelOffsetY}); var movementResolved = false; var boxPushed = false;prevLevelOffsetX = 0; prevLevelOffsetY = 0;var target = wrapCoords(player.x + horDelta, player.y + verDelta); var targetX = target.x; var targetY = target.y;let foundBox = hasBox(targetX, targetY);if (foundBox !== null) { var boxTarget = wrapCoords(targetX + horDelta, targetY + verDelta); let boxTargetX = boxTarget.x; let boxTargetY = boxTarget.y;if (hasWall(boxTargetX, boxTargetY) === null && hasBox(boxTargetX, boxTargetY) === null && hasRubble(boxTargetX, boxTargetY) === null) { boxes[foundBox] = {x: boxTargetX, y: boxTargetY, shift: boxes[foundBox].shift}; player = {x: targetX, y: targetY}; movementResolved = true; boxPushed = true;if (boxes[foundBox].shift != 0) { if (boxes[foundBox].shift == 1 || boxes[foundBox].shift == 3) {ShiftX(horDelta); }if (boxes[foundBox].shift == 2 || boxes[foundBox].shift == 3) {ShiftY(verDelta); } } } else { console.log("Movement not resolved","Could not push box"); } } else if (hasWall(targetX, targetY) === null && hasClosedGate(targetX, targetY) === null) { player = {x: targetX, y: targetY}; movementResolved = true; } else { console.log("Movement not resolved","Something was in the way"); } }if (movementResolved) { if (!boxPushed) { steps += dir; } else { steps += dir.toUpperCase(); } timeSinceLastAction = 0;prevHorDelta = horDelta; prevVerDelta = verDelta;freshState = false;if (level == 0) { var lvl = hasLevelNode(player.x, player.y); setLevelName(lvl,1); }if (autoScrollX) { ShiftX(autoScrollX); } else if (autoScrollY) { ShiftY(autoScrollY); } var hasWon = true; if (boxPushed && targets.length > 0) {for(let i = 0; i != targets.length; i++) { if (hasBox(targets[i].x, targets[i].y) === null) { hasWon = false; break; } } } else { hasWon = false; }if (hasWon) { console.warn("Victory!",steps + " (" + steps.length + ")"); if (levelSolved[level] != 2) { levelSolved[level] = 2; amountOfLevelsSolved++; } saveGame();audio("victory", true); victory = true; timeSinceLevelWon = 0; } else { if (boxPushed) { if (prevLevelOffsetX != 0 || prevLevelOffsetY != 0) { audio("shift"); } else { audio("push"); } } else { audio("walk"); } } } else { if (horDelta != 0 || verDelta != 0) { audio("bump"); undoStack.pop();} camShakeX = horDelta * 12; camShakeY = verDelta * 12; }function ShiftX(horDelta) { if (levelOffsetY == 0) { levelOffsetX -= horDelta; prevLevelOffsetX = -horDelta; timeSinceLastAction = 0; if (levelOffsetX >= gridWidth * 0.5) { levelOffsetX -= gridWidth; } else if (levelOffsetX <= -gridWidth * 0.5) { levelOffsetX += gridWidth; } } else { console.log("Shifting not resolved: Cannot shift X when Y is shifted") } }function ShiftY(verDelta) { if (levelOffsetX == 0) { levelOffsetY -= verDelta; prevLevelOffsetY = -verDelta; timeSinceLastAction = 0; if (levelOffsetY >= gridHeight * 0.5) { levelOffsetY -= gridHeight; } else if (levelOffsetY <= -gridHeight * 0.5) { levelOffsetY += gridHeight; } } else { console.log("Shifting not resolved: Cannot shift Y when X is shifted") } } }function audio(soundID, alwaysPlay = false) { if (!audioEnabled) {return;}if (timeSinceLastAudio >= timeUntilPlayableAudio || alwaysPlay) { if (!alwaysPlay) {timeSinceLastAudio = 0;} switch (soundID.toLowerCase()) { case "select": zzfx(...[,.3,176,.02,,.08,3,.4,-0.7,-21,-127,.01,.05,,,,.38,,.03]); break; case "bump": zzfx(...[,.3,220,.02,,.08,3,.4,-0.7,-21,-127,.01,.05,,,,.38,,.03]); case "walk": zzfx(...[.6,.1,176,.02,,.01,3,.4,-0.7,-21,-127,.01,.05,,,,.1,,.02]); break; case "push": zzfx(...[.5,.1,220,.02,,.01,3,.4,-0.7,-21,-127,.01,.05,,,,.1,,.02]); break; case "shift": zzfx(...[.45,.1,250,.02,,.01,3,.4,-0.7,-21,-127,.01,.05,,,.1,.1,,.02]); break; case "victory": zzfx(...[.6,,934,.12,.38,.93,1,.27,,.4,-434,.08,.2,.1,,.1,.17,.55,1,.46]); break; case "undo":zzfx(...[,,110,,,,1,1.82,,.1,,,,.1,,.1,.01,.7,.02,.15]); break; case "restart": zzfx(...[,,283,.02,,.11,,.38,,,,,.07,,,.1,.08,.63,.02]); break; case "menu": zzfx(...[,.02,1638,,.05,.17,1,,,,490,.09,,,,.1,.05,.5,.03]); break; case "back": zzfx(...[,,98,.08,.18,.02,2,2.47,36,.5,,,.04,.1,,.9,.44,,.04]); break; case "gameend": zzfx(...[,,525,.18,.28,.17,1,1.24,8.3,-9.7,-151,.03,.06,,,,,.93,.02,.14]); } } }function saveGame() { var ls = window.localStorage;var levelsSaved = ""; for (var i = 1; i != levelSolved.length; i += 1) { if (levelSolved[i] == 2) { levelsSaved += "t"; } else if (levelSolved[i] == 1) { levelsSaved += "f"; } else { levelsSaved += "n"; } }ls.setItem("banbanban-levelsSolved",levelsSaved); ls.setItem("banbanban-color",colorTheme); ls.setItem("banbanban-audio", audioEnabled); ls.setItem("banbanban-reduceMotion", reduceMotion); ls.setItem("banbanban-version", 1); }function loadGame() { var ls = window.localStorage;var loadedValue = ls.getItem("banbanban-levelsSolved");if (loadedValue != null) { for (var i = 1; i != levelSolved.length; i += 1) { if (loadedValue[i-1] == "t") { levelSolved[i] = 2; amountOfLevelsSolved++; } else if (loadedValue[i-1] == "f") { levelSolved[i] = 1; } } }var loadedValue = parseInt(ls.getItem("banbanban-color")); if (loadedValue >= 0 && loadedValue < colors.length) { colorTheme = loadedValue; }var loadedValue = ls.getItem("banbanban-audio"); if (loadedValue == "false") { audioEnabled = false; }var loadedValue = ls.getItem("banbanban-reduceMotion"); reduceMotion = loadedValue == "true"; }function setLevelName(lvl, offset = 0) { var prevName = levelName; if (level != 0 && !levelSolved.includes(2)) { levelName = "Push the box to the goal!"; } else if (lvl != null && lvl + offset != 0) { levelName = levels[lvl + offset][0].nr+": "+levels[lvl + offset][0].name; if (level == 0) { levelName += " - [Space] to enter"; } } else if (!levelSolved.includes(2)) { levelName = "WASD/Arrow Keys to move"; } else { levelName = ""; } if (prevName != levelName) { timeSinceLevelNameChanged = 0; } }function blendColors(colorA, colorB, amount) { const [rA, gA, bA] = colorA.match(/\w\w/g).map((c) => parseInt(c, 16)); const [rB, gB, bB] = colorB.match(/\w\w/g).map((c) => parseInt(c, 16)); const r = Math.round(rA + (rB - rA) * amount).toString(16).padStart(2, '0'); const g = Math.round(gA + (gB - gA) * amount).toString(16).padStart(2, '0'); const b = Math.round(bA + (bB - bA) * amount).toString(16).padStart(2, '0'); return '#' + r + g + b; }console.warn("Todo: Polish, QA, make final level");</script>
    </body></html>