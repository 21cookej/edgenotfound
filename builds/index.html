<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Edge Not Found</title>
    <style>html, body, canvas {width:100%;height: 100%;margin: 0;overflow: hidden;}</style>
    <link rel="icon" type="image/ico"><meta property="og:title" content="Edge Not Found" /><meta property="og:description" content="Edge Not Found is a Sokoban-style puzzle game set on an infinitely repeating grid. Push the boxes to the targets in ~20 puzzles." /></head><body><noscript>Please enable Javascript to play this game!</noscript><canvas id="canvas" width="500" height="500"> </canvas>
    <script> class Timing{constructor(minFrameLength, maxFrameLength){this.minFrameLength=minFrameLength;this.maxFrameLength=maxFrameLength;this.lastUpdate=new Date();this.currentFrameLength=0;this.stepsProcessed=0;this.timePlaying=0;}update(overwrite=null){const newUpdate=new Date();if(!overwrite){this.currentFrameLength=(newUpdate - this.lastUpdate) / 1000;}else{this.currentFrameLength=overwrite;}this.lastUpdate=newUpdate;this.timePlaying += this.currentFrameLength;this.stepsProcessed += 1;}fps(){return (1 / this.currentFrameLength)}perSecond(v){return v * this.currentFrameLength;}}const pressedState={IDLE: 0, PRESSED: 1, HELD: 2, RELEASED: 3};class InputHandler{constructor(positiveKeys, negativeKeys=null, timer=null, timeForRefiring=0, extraTimeForFirstRefire=0){this.delta=0;this.posKeysHeld=[];this.negKeysHeld=[];this.timer=timer;this.prevHeldTime=0;this.heldTime=0;this.fired=false;this.waitForRefiring=timeForRefiring;this.firstWaitForRefiring=timeForRefiring + extraTimeForFirstRefire;this.timeSinceLastRefire=0;this.timesFired=0;this.state=pressedState.IDLE;if(positiveKeys){positiveKeys.forEach((element) =>{window.addEventListener('keydown', (event) =>{if(this.change(event, element)){var push=PushUnique(this.posKeysHeld, element);if(push.changed){this.posKeysHeld=push.array;this.updateDelta();}}});window.addEventListener('keyup', (event) =>{if(this.change(event, element)){this.posKeysHeld=SpliceUnique(this.posKeysHeld, element);this.updateDelta();}});});}this.positiveKeys=positiveKeys;if(negativeKeys){negativeKeys.forEach((element) =>{window.addEventListener('keydown', (event) =>{if(this.change(event, element)){var push=PushUnique(this.negKeysHeld, element);if(push.changed){this.negKeysHeld=push.array;this.updateDelta();}}});window.addEventListener('keyup', (event) =>{if(this.change(event, element)){this.negKeysHeld=SpliceUnique(this.negKeysHeld, element);this.updateDelta();}});});}this.negativeKeys=negativeKeys;}change(event, element){return (event.code==element||event.keyCode==element);}updateDelta(){const diff=this.posKeysHeld.length - this.negKeysHeld.length;if(diff > 0&&this.delta!=1){this.delta=1;this.heldTime=0;this.timesFired=0;this.timeSinceLastRefire=0;}else if(diff < 0&&this.delta!=-1){this.delta=-1;this.heldTime=0;this.timesFired=0;this.timeSinceLastRefire=0;}else if(this.delta!=0){this.delta=0;this.heldTime=0;this.timesFired=0;this.timeSinceLastRefire=0;}}update(){if(this.timer&&this.delta!=0){this.heldTime += this.timer.currentFrameLength;this.timeSinceLastRefire += this.timer.currentFrameLength;if(this.prevHeldTime==0||(this.timesFired > 1&&this.timeSinceLastRefire >= this.waitForRefiring)||(this.timesFired <= 1&&this.timeSinceLastRefire >= this.firstWaitForRefiring)){this.fired=true;this.timesFired += 1;this.timeSinceLastRefire=0;}else{this.fired=false;}}else{this.fired=false;}if(this.delta==0){if(this.prevHeldTime!=0){this.state=pressedState.RELEASED;}else{this.state=pressedState.IDLE;}}else{if(this.prevHeldTime==0){this.state=pressedState.PRESSED;}else{this.state=pressedState.HELD;}}this.prevHeldTime=this.heldTime;}}function Clamp(nr, min, max){return Math.max(min, Math.min(nr, max));}function PushUnique(array, newEntry){var changed=false;if(array.indexOf(newEntry) === -1){array.push(newEntry);changed=true;}return{array: array, changed: changed};}function SpliceUnique(array, EntryToSplice){const index=array.indexOf(EntryToSplice);if(index > -1){array.splice(index, 1);}return array;}
    var rough=function(){function t(t, e, s){if(t&&t.length){const [n, o]=e, a=Math.PI / 180 * s, r=Math.cos(a), h=Math.sin(a);t.forEach(t =>{const [e, s]=t;t[0]=(e - n) * r - (s - o) * h + n, t[1]=(e - n) * h + (s - o) * r + o})}}function e(t){const e=t[0], s=t[1];return Math.sqrt(Math.pow(e[0] - s[0], 2) + Math.pow(e[1] - s[1], 2))}function s(t, e, s, n){const o=e[1] - t[1], a=t[0] - e[0], r=o * t[0] + a * t[1], h=n[1] - s[1], i=s[0] - n[0], c=h * s[0] + i * s[1], l=o * i - h * a;return l ? [(i * r - a * c) / l, (o * c - h * r) / l] : null}function n(t, e, s){const n=t.length;if(n < 3) return !1;const h=[Number.MAX_SAFE_INTEGER, s], i=[e, s];let c=0;for (let e=0;e < n;e++){const s=t[e], l=t[(e + 1) % n];if(r(s, l, i, h)){if(0 === a(s, i, l)) return o(s, i, l);c++}}return c % 2==1}function o(t, e, s){return e[0] <= Math.max(t[0], s[0])&&e[0] >= Math.min(t[0], s[0])&&e[1] <= Math.max(t[1], s[1])&&e[1] >= Math.min(t[1], s[1])}function a(t, e, s){const n=(e[1] - t[1]) * (s[0] - e[0]) - (e[0] - t[0]) * (s[1] - e[1]);return 0 === n ? 0 : n > 0 ? 1 : 2}function r(t, e, s, n){const r=a(t, e, s), h=a(t, e, n), i=a(s, n, t), c=a(s, n, e);return r !== h&&i !== c||(!(0 !== r||!o(t, s, e))||(!(0 !== h||!o(t, n, e))||(!(0 !== i||!o(s, t, n))||!(0 !== c||!o(s, e, n)))))}function h(e, s){const n=[0, 0], o=Math.round(s.hachureAngle + 90);o&&t(e, n, o);const a=function(t, e){const s=[...t];s[0].join(",") !== s[s.length - 1].join(",")&&s.push([s[0][0], s[0][1]]);const n=[];if(s&&s.length > 2){let t=e.hachureGap;t < 0&&(t=4 * e.strokeWidth), t=Math.max(t, .1);const o=[];for (let t=0;t < s.length - 1;t++){const e=s[t], n=s[t + 1];if(e[1] !== n[1]){const t=Math.min(e[1], n[1]);o.push({ymin: t, ymax: Math.max(e[1], n[1]), x: t === e[1] ? e[0] : n[0], islope: (n[0] - e[0]) / (n[1] - e[1])})}}if(o.sort((t, e) => t.ymin < e.ymin ? -1 : t.ymin > e.ymin ? 1 : t.x < e.x ? -1 : t.x > e.x ? 1 : t.ymax === e.ymax ? 0 : (t.ymax - e.ymax) / Math.abs(t.ymax - e.ymax)), !o.length) return n;let a=[], r=o[0].ymin;for (;a.length||o.length;){if(o.length){let t=-1;for (let e=0;e < o.length&&!(o[e].ymin > r);e++) t=e;o.splice(0, t + 1).forEach(t =>{a.push({s: r, edge: t})})}if(a=a.filter(t => !(t.edge.ymax <= r)), a.sort((t, e) => t.edge.x === e.edge.x ? 0 : (t.edge.x - e.edge.x) / Math.abs(t.edge.x - e.edge.x)), a.length > 1) for (let t=0;t < a.length;t += 2){const e=t + 1;if(e >= a.length) break;const s=a[t].edge, o=a[e].edge;n.push([ [Math.round(s.x), r], [Math.round(o.x), r] ])}r += t, a.forEach(e =>{e.edge.x=e.edge.x + t * e.edge.islope})}}return n}(e, s);return o&&(t(e, n, -o), function(e, s, n){const o=[];e.forEach(t => o.push(...t)), t(o, s, n)}(a, n, -o)), a}class i{constructor(t){this.helper=t}fillPolygon(t, e){return this._fillPolygon(t, e)}_fillPolygon(t, e, s=!1){let n=h(t, e);if(s){const e=this.connectingLines(t, n);n=n.concat(e)}return{type: "fillSketch", ops: this.renderLines(n, e)}}renderLines(t, e){const s=[];for (const n of t) s.push(...this.helper.doubleLineOps(n[0][0], n[0][1], n[1][0], n[1][1], e));return s}connectingLines(t, s){const n=[];if(s.length > 1) for (let o=1;o < s.length;o++){const a=s[o - 1];if(e(a) < 3) continue;const r=[s[o][0], a[1]];if(e(r) > 3){const e=this.splitOnIntersections(t, r);n.push(...e)}}return n}midPointInPolygon(t, e){return n(t, (e[0][0] + e[1][0]) / 2, (e[0][1] + e[1][1]) / 2)}splitOnIntersections(t, o){const a=Math.max(5, .1 * e(o)), h=[];for (let n=0;n < t.length;n++){const i=t[n], c=t[(n + 1) % t.length];if(r(i, c, ...o)){const t=s(i, c, o[0], o[1]);if(t){const s=e([t, o[0]]), n=e([t, o[1]]);s > a&&n > a&&h.push({point: t, distance: s})}}}if(h.length > 1){const e=h.sort((t, e) => t.distance - e.distance).map(t => t.point);if(n(t, ...o[0])||e.shift(), n(t, ...o[1])||e.pop(), e.length <= 1) return this.midPointInPolygon(t, o) ? [o] : [];const s=[o[0], ...e, o[1]], a=[];for (let e=0;e < s.length - 1;e += 2){const n=[s[e], s[e + 1]];this.midPointInPolygon(t, n)&&a.push(n)}return a}return this.midPointInPolygon(t, o) ? [o] : []}}class c extends i{fillPolygon(t, e){return this._fillPolygon(t, e, !0)}}class u{constructor(t){this.helper=t}fillPolygon(t, e){const s=h(t, e=Object.assign({}, e,{curveStepCount: 4, hachureAngle: 0, roughness: 1}));return this.dotsOnLines(s, e)}dotsOnLines(t, s){const n=[];let o=s.hachureGap;o < 0&&(o=4 * s.strokeWidth), o=Math.max(o, .1);let a=s.fillWeight;a < 0&&(a=s.strokeWidth / 2);const r=o / 4;for (const h of t){const t=e(h), i=t / o, c=Math.ceil(i) - 1, l=t - c * o, u=(h[0][0] + h[1][0]) / 2 - o / 4, f=Math.min(h[0][1], h[1][1]);for (let t=0;t < c;t++){const e=f + l + t * o, h=this.helper.randOffsetWithRange(u - r, u + r, s), i=this.helper.randOffsetWithRange(e - r, e + r, s), c=this.helper.ellipse(h, i, a, a, s);n.push(...c.ops)}}return{type: "fillSketch", ops: n}}}const d={};class g{constructor(t){this.seed=t}next(){return this.seed ? (2 ** 31 - 1 & (this.seed=Math.imul(48271, this.seed))) / 2 ** 31 : Math.random()}}const x={randOffset: function(t, e){return W(t, e)}, randOffsetWithRange: function(t, e, s){return E(t, e, s)}, ellipse: function(t, e, s, n, o){const a=T(s, n, o);return I(t, e, o, a).opset}, doubleLineOps: function(t, e, s, n, o){return z(t, e, s, n, o, !0)}};function v(t, e, s, n, o){return{type: "path", ops: z(t, e, s, n, o)}}function O(t, e, s){const n=(t||[]).length;if(n > 2){const o=[];for (let e=0;e < n - 1;e++) o.push(...z(t[e][0], t[e][1], t[e + 1][0], t[e + 1][1], s));return e&&o.push(...z(t[n - 1][0], t[n - 1][1], t[0][0], t[0][1], s)),{type: "path", ops: o}}return 2 === n ? v(t[0][0], t[0][1], t[1][0], t[1][1], s) :{type: "path", ops: []}}function S(t, e, s, n, o){return function(t, e){return O(t, !0, e)}([ [t, e], [t + s, e], [t + s, e + n], [t, e + n] ], o)}function T(t, e, s){const n=Math.sqrt(2 * Math.PI * Math.sqrt((Math.pow(t / 2, 2) + Math.pow(e / 2, 2)) / 2)), o=Math.max(s.curveStepCount, s.curveStepCount / Math.sqrt(200) * n), a=2 * Math.PI / o;let r=Math.abs(t / 2), h=Math.abs(e / 2);const i=1 - s.curveFitting;return r += W(r * i, s), h += W(h * i, s),{increment: a, rx: r, ry: h}}function I(t, e, s, n){const [o, a]=q(n.increment, t, e, n.rx, n.ry, 1, n.increment * E(.1, E(.4, 1, s), s), s);let r=G(o, null, s);if(!s.disableMultiStroke){const [o]=q(n.increment, t, e, n.rx, n.ry, 1.5, 0, s), a=G(o, null, s);r=r.concat(a)}return{estimatedPoints: a, opset:{type: "path", ops: r}}}function _(t, e){const s=[];if(t.length){const n=e.maxRandomnessOffset||0, o=t.length;if(o > 2){s.push({op: "move", data: [t[0][0] + W(n, e), t[0][1] + W(n, e)]});for (let a=1;a < o;a++) s.push({op: "lineTo", data: [t[a][0] + W(n, e), t[a][1] + W(n, e)]})}}return{type: "fillPath", ops: s}}function C(t, e){return function(t, e){let s=t.fillStyle||"hachure";if(!d[s]) switch (s){case "zigzag": d[s]||(d[s]=new c(e));break;case "dots": d[s]||(d[s]=new u(e));break;case "hachure": default: s="hachure", d[s]||(d[s]=new i(e))}return d[s]}(e, x).fillPolygon(t, e)}function D(t){return t.randomizer||(t.randomizer=new g(t.seed||0)), t.randomizer.next()}function E(t, e, s, n=1){return s.roughness * n * (D(s) * (e - t) + t)}function W(t, e, s=1){return E(-t, t, e, s)}function z(t, e, s, n, o, a=!1){const r=a ? o.disableMultiStrokeFill : o.disableMultiStroke, h=R(t, e, s, n, o, !0, !1);if(r) return h;const i=R(t, e, s, n, o, !0, !0);return h.concat(i)}function R(t, e, s, n, o, a, r){const h=Math.pow(t - s, 2) + Math.pow(e - n, 2), i=Math.sqrt(h);let c=1;let l=o.maxRandomnessOffset||0;l * l * 100 > h&&(l=i / 10);const u=l / 2, f=.2 + .2 * D(o);let p=o.bowing * o.maxRandomnessOffset * (n - e) / 200, d=o.bowing * o.maxRandomnessOffset * (t - s) / 200;p=W(p, o, c), d=W(d, o, c);const g=[], M=() => W(u, o, c), k=() => W(l, o, c);return a&&(r ? g.push({op: "move", data: [t + M(), e + M()]}) : g.push({op: "move", data: [t + W(l, o, c), e + W(l, o, c)]})), r ? g.push({op: "bcurveTo", data: [p + t + (s - t) * f + M(), d + e + (n - e) * f + M(), p + t + 2 * (s - t) * f + M(), d + e + 2 * (n - e) * f + M(), s + M(), n + M()]}) : g.push({op: "bcurveTo", data: [p + t + (s - t) * f + k(), d + e + (n - e) * f + k(), p + t + 2 * (s - t) * f + k(), d + e + 2 * (n - e) * f + k(), s + k(), n + k()]}), g}function G(t, e, s){const n=t.length, o=[];if(n > 3){const a=[], r=1 - s.curveTightness;o.push({op: "move", data: [t[1][0], t[1][1]]});for (let e=1;e + 2 < n;e++){const s=t[e];a[0]=[s[0], s[1]], a[1]=[s[0] + (r * t[e + 1][0] - r * t[e - 1][0]) / 6, s[1] + (r * t[e + 1][1] - r * t[e - 1][1]) / 6], a[2]=[t[e + 1][0] + (r * t[e][0] - r * t[e + 2][0]) / 6, t[e + 1][1] + (r * t[e][1] - r * t[e + 2][1]) / 6], a[3]=[t[e + 1][0], t[e + 1][1]], o.push({op: "bcurveTo", data: [a[1][0], a[1][1], a[2][0], a[2][1], a[3][0], a[3][1]]})}if(e&&2 === e.length){const t=s.maxRandomnessOffset;o.push({op: "lineTo", data: [e[0] + W(t, s), e[1] + W(t, s)]})}}else 3 === n ? (o.push({op: "move", data: [t[1][0], t[1][1]]}), o.push({op: "bcurveTo", data: [t[1][0], t[1][1], t[2][0], t[2][1], t[2][0], t[2][1]]})) : 2 === n&&o.push(...z(t[0][0], t[0][1], t[1][0], t[1][1], s));return o}function q(t, e, s, n, o, a, r, h){const i=[], c=[], l=W(.5, h) - Math.PI / 2;c.push([W(a, h) + e + .9 * n * Math.cos(l - t), W(a, h) + s + .9 * o * Math.sin(l - t)]);for (let r=l;r < 2 * Math.PI + l - .01;r += t){const t=[W(a, h) + e + n * Math.cos(r), W(a, h) + s + o * Math.sin(r)];i.push(t), c.push(t)}return c.push([W(a, h) + e + n * Math.cos(l + 2 * Math.PI + .5 * r), W(a, h) + s + o * Math.sin(l + 2 * Math.PI + .5 * r)]), c.push([W(a, h) + e + .98 * n * Math.cos(l + r), W(a, h) + s + .98 * o * Math.sin(l + r)]), c.push([W(a, h) + e + .9 * n * Math.cos(l + .5 * r), W(a, h) + s + .9 * o * Math.sin(l + .5 * r)]), [c, i]}const K="none";class U{constructor(t){this.defaultOptions={maxRandomnessOffset: 2, roughness: 1, bowing: 1, stroke: "#000", strokeWidth: 1, curveTightness: 0, curveFitting: .95, curveStepCount: 9, fillStyle: "hachure", fillWeight: -1, hachureAngle: -41, hachureGap: -1, dashOffset: -1, dashGap: -1, zigzagOffset: -1, seed: 0, combineNestedSvgPaths: !1, disableMultiStroke: !1, disableMultiStrokeFill: !1}, this.config=t ||{}, this.config.options&&(this.defaultOptions=this._o(this.config.options))}static newSeed(){return Math.floor(Math.random() * 2 ** 31)}_o(t){return t ? Object.assign({}, this.defaultOptions, t) : this.defaultOptions}_d(t, e, s){return{shape: t, sets: e||[], options: s||this.defaultOptions}}line(t, e, s, n, o){const a=this._o(o);return this._d("line", [v(t, e, s, n, a)], a)}rectangle(t, e, s, n, o){const a=this._o(o), r=[], h=S(t, e, s, n, a);if(a.fill){const o=[ [t, e], [t + s, e], [t + s, e + n], [t, e + n] ];"solid" === a.fillStyle ? r.push(_(o, a)) : r.push(C(o, a))}return a.stroke !== K&&r.push(h), this._d("rectangle", r, a)}ellipse(t, e, s, n, o){const a=this._o(o), r=[], h=T(s, n, a), i=I(t, e, a, h);if(a.fill) if("solid" === a.fillStyle){const s=I(t, e, a, h).opset;s.type="fillPath", r.push(s)}else r.push(C(i.estimatedPoints, a));return a.stroke !== K&&r.push(i.opset), this._d("ellipse", r, a)}circle(t, e, s, n){const o=this.ellipse(t, e, s, s, n);return o.shape="circle", o}polygon(t, e){const s=this._o(e), n=[], o=O(t, !0, s);return s.fill&&("solid" === s.fillStyle ? n.push(_(t, s)) : n.push(C(t, s))), s.stroke !== K&&n.push(o), this._d("polygon", n, s)}}class Y{constructor(t, e){this.canvas=t, this.ctx=this.canvas.getContext("2d"), this.gen=new U(e)}draw(t){const e=t.sets||[], s=t.options||this.getDefaultOptions(), n=this.ctx;for (const o of e) switch (o.type){case "path": n.save(), n.strokeStyle="none" === s.stroke ? "transparent" : s.stroke, n.lineWidth=s.strokeWidth, s.strokeLineDash&&n.setLineDash(s.strokeLineDash), s.strokeLineDashOffset&&(n.lineDashOffset=s.strokeLineDashOffset), this._drawToContext(n, o), n.restore();break;case "fillPath": n.save(), n.fillStyle=s.fill||"";const e="curve" === t.shape||"polygon" === t.shape ? "evenodd" : "nonzero";this._drawToContext(n, o, e), n.restore();break;case "fillSketch": this.fillSketch(n, o, s)}}fillSketch(t, e, s){let n=s.fillWeight;n < 0&&(n=s.strokeWidth / 2), t.save(), s.fillLineDash&&t.setLineDash(s.fillLineDash), s.fillLineDashOffset&&(t.lineDashOffset=s.fillLineDashOffset), t.strokeStyle=s.fill||"", t.lineWidth=n, this._drawToContext(t, e), t.restore()}_drawToContext(t, e, s="nonzero"){t.beginPath();for (const s of e.ops){const e=s.data;switch (s.op){case "move": t.moveTo(e[0], e[1]);break;case "bcurveTo": t.bezierCurveTo(e[0], e[1], e[2], e[3], e[4], e[5]);break;case "lineTo": t.lineTo(e[0], e[1])}}"fillPath" === e.type ? t.fill(s) : t.stroke()}getDefaultOptions(){return this.gen.defaultOptions}line(t, e, s, n, o){const a=this.gen.line(t, e, s, n, o);return this.draw(a), a}rectangle(t, e, s, n, o){const a=this.gen.rectangle(t, e, s, n, o);return this.draw(a), a}ellipse(t, e, s, n, o){const a=this.gen.ellipse(t, e, s, n, o);return this.draw(a), a}circle(t, e, s, n){const o=this.gen.circle(t, e, s, n);return this.draw(o), o}}return{canvas: (t, e) => new Y(t, e), generator: t => new U(t), newSeed: () => U.newSeed()}}();
    zzfxV=.15;zzfx=(q=1,k=.05,c=220,e=0,t=0,u=.1,r=0,F=1,v=0,z=0,w=0,A=0,l=0,B=0,x=0,G=0,d=0,y=1,m=0,C=0)=>{let b=2*Math.PI,H=v*=500*b/zzfxR**2,I=(0<x?1:-1)*b/4,D=c*=(1+2*k*Math.random()-k)*b/zzfxR,Z=[],g=0,E=0,a=0,n=1,J=0,K=0,f=0,p,h;e=99+zzfxR*e;m*=zzfxR;t*=zzfxR;u*=zzfxR;d*=zzfxR;z*=500*b/zzfxR**3;x*=b/zzfxR;w*=b/zzfxR;A*=zzfxR;l=zzfxR*l|0;for(h=e+m+t+u+d|0;a<h;Z[a++]=f)++K%(100*G|0)||(f=r?1<r?2<r?3<r?Math.sin((g%b)**3):Math.max(Math.min(Math.tan(g),1),-1):1-(2*g/b%2+2)%2:1-4*Math.abs(Math.round(g/b)-g/b):Math.sin(g),f=(l?1-C+C*Math.sin(2*Math.PI*a/l):1)*(0<f?1:-1)*Math.abs(f)**F*q*zzfxV*(a<e?a/e:a<e+m?1-(a-e)/m*(1-y):a<e+m+t?y:a<h-d?(h-a-d)/u*y:0),f=d?f/2+(d>a?0:(a<h-d?1:(h-a)/d)*Z[a-d|0]/2):f),p=(c+=v+=z)*Math.sin(E*x-I),g+=p-p*B*(1-1E9*(Math.sin(a)+1)%2),E+=p-p*B*(1-1E9*(Math.sin(a)**2+1)%2),n&&++n>A&&(c+=w,D+=w,n=0),!l||++J%l||(c=D,v=H,n=n||1);q=zzfxX.createBuffer(1,h,zzfxR);q.getChannelData(0).set(Z);c=zzfxX.createBufferSource();c.buffer=q;c.connect(zzfxX.destination);c.start();return c};zzfxX=new(window.AudioContext||webkitAudioContext);zzfxR=44100
    var levels=[];levels.push([{gates: [1, 3, 6, 12, 15], levelSpread: [1, 5, 10, 17], yOff: -2},"##########.", "p1g.1.1.1.g", "##########.", "2.2.2.2.2.g", "##########.", ".333.3333.g", "##########.", "4.4.4.4g4#." ]);levels.push([{nr: 100, name: "A Wrapping World"},"#####.#", "......#", "...#..#", "#.###.#", ".b#t.p.", "..###.#", ]);levels.push([{nr: 101, name: "Infinite Inlet"}, "..#", "p.#", ".tbt", "#b.b", ".tbt", ]);levels.push([{nr: 102, name: "Glass Hallway"},"##.##", ".t.tp", "bb#bb", ".t.t", "##.##" ]);levels.push([{nr: 103, name: "Girded Grid"},".#.#.#", "t.b.t", ".#.#.#", "b.p.b", ".#.#.#", "t.b.t" ]);levels.push([{nr: 200, name: "Wrap Around The Block", yOff: 2},"", "####", "", "####", "..b", "####", "t#.p", "####" ]);levels.push([{nr: 201, name: "Crowned Conundrum", xOff: 3},"pb...b", "b#.#.#", ".#ttt#", ]);levels.push([{nr: 202, name: "Twisted Terrace", xOff: 3},"b..p", ".##.##", ".#.t.#", "bbt#tb", ".#.t.#", ".##.##" ]);levels.push([{nr: 203, name: "Continuous Corridor", yOff: 3},"######", "tb..p", "t....b", "######", "t#...b", "tb...#" ]);levels.push([{nr: 204, name: "Grandiose Garden", yOff: 3},"..bpb", "..#.#", ".#.t.#", ".bt.tb", ".#.t.#", "..#.#" ]);levels.push([{nr: 300, name: "Sift & Shift"},"bt##|#", "###p", "####.#" ]);levels.push([{nr: 301, name: "Cornered Contraption", yOff: 1},"p", ".|", "#####", ".t#", "###" ]);levels.push([{nr: 302, name: "Zealous Zigzag"},"#t#t#t", ".-..-", "###..#", ".p####", ".-", ]);levels.push([{nr: 303, name: "Irregular Infrastructure", yOff: 2},"##.|", ".#..p", ".#..#", ".#.#t", "....#", "" ]);levels.push([{nr: 304, name: "Enchanted Encagement"},"##.#.###.#.#", "#..-..#....#", "#..p..#.t.t", "#..-..##", "##.#.###.#.#", ]);levels.push([{nr: 305, name: "Riddle Raster", yOff: -1},"", ".t", "#|#", ".t", "#b#", "pt", "#|#", ]);levels.push([{nr: 306, name: "Locked Loungerooms", yOff: -2},"#########", "####..###", ".......##", "####....#", "####", "....#...#", "#....#", "...||.###", "##.p", "tt#...###", ]);levels.push([{nr: 400, name: "Rubble Rundown"},"rrr#..r#", ".pb...r#", "#t######" ]);levels.push([{nr: 401, name: "Quality Questions", yOff: -2},"rrrrrrr", "#t|#|t#", "#|t#t|#", "rrrprrr", "#######", "rrrrrrr", "#t#|#t#", "#|#t#|#", "rrrrrrr", "#######", ]);levels.push([{nr: 402, name: "Swirling Stars"}, "....#r+tr", "b##..r.rb", "b.##..r.b", "..t...p", "#ttt#rrr#", ]);levels.push([{nr: 403, name: "Box Breakout"},"b.#.#.b", ".#rpr#", "#rrtrr#", "...+", "#rrtrr#", ".#r.r#.","b.#.#.b", ]);levels.push([{nr: 404, name: "Edge Not Found", autoX: -1}, "#.##.#...#", "#b##.#...#", "#p##t#####", "##..######", "##..######" ]);
    const M=Math;const S="px sans-serif";var scale=70;var roughSeed=1;const timing=new Timing((1/ 10), (1 / 60));const canvas=document.getElementById("canvas");const ctx=canvas.getContext("2d",{alpha: false});const roughCanvas=rough.canvas(canvas);const levelCanvas=document.createElement("canvas");const levelCtx=levelCanvas.getContext("2d");const roughLevel=rough.canvas(levelCanvas);const wallCanvas=document.createElement("canvas");const wallCtx=wallCanvas.getContext("2d");const roughWall=rough.canvas(wallCanvas);const wallMargin=10;const playerCanvas=document.createElement("canvas");const PlayerCtx=playerCanvas.getContext("2d");const roughPlayer=rough.canvas(playerCanvas);const boxCanvas=document.createElement("canvas");const boxCtx=boxCanvas.getContext("2d");const roughBox=rough.canvas(boxCanvas);const boxMargin=10;const targetCanvas=document.createElement("canvas");const targetCtx=targetCanvas.getContext("2d");const roughTarget=rough.canvas(targetCanvas);const targetMargin=15;const rubbleCanvas=document.createElement("canvas");const rubbleCtx=rubbleCanvas.getContext("2d");const roughRubble=rough.canvas(rubbleCanvas);const rubbleMargin=15;let undoStack=[];var camShakeX=0;var camShakeY=0;var gameName="Edge Not Found ";var subTitle="Press any key";var levelName="";var levelOffsetX=0;var levelOffsetY=0;var autoScrollX=0;var autoScrollY=0;var prevLevelOffsetX=0;var prevLevelOffsetY=0;onkeydown=function(e){if(e.key=="ArrowDown"||e.key=="ArrowUp"||e.key==" "||e.key=="Backspace"){e.preventDefault();}input(e);};window.onbeforeunload=function(){return "Quit?";};var favicon=null;var wroteFavicon=false;onload=function(e){favicon=document.querySelector('link[rel="icon"]');};var level=0;var gridHeight=levels[level].length;var gridWidth=levels[level][0].length;var player={x: 0, y: 0};var walls=[];var boxes=[];var targets=[];var levelNodes=[];var gates=[];var rubble=[];var steps="";var prevHorDelta=0;var prevVerDelta=0;var timeSinceLastAction=0;var timeToCompleteTween=0.1;var timeToUpdateRenders=(1/3);var timeSinceUpdatedRenders=timeToUpdateRenders;var timeUntilLevelEnd=4;var timeUntilLevelSelected=1;var timeSinceLevelWon=timeUntilLevelEnd;var timeSinceLevelStart=0;var timeToLoadLevel=1;var timeUntilChangableTheme=0.2;var timeSinceLastThemeChange=0;var timeUntilPlayableAudio=0.075;var timeSinceLastAudio=0;var timeToDisplayLevelName=0.2;var timeSinceLevelNameChanged=0;var timeToToggleMenu=0.25;var timeSinceMenuToggled=timeToToggleMenu;var menuOpened=false;var menuSelection=0;var titleScreen=true;var verticalInput=new InputHandler(["KeyS", "ArrowDown"], ["KeyW", "ArrowUp"], timing, 0.1, 0.2);var horizontalInput=new InputHandler(["KeyD", "ArrowRight"], ["KeyA", "ArrowLeft"], timing, 0.1, 0.2);var undoInput=new InputHandler(["KeyZ", "Backspace"], [], timing, 0.1, 0.2);var confirmInput=new InputHandler(["KeyX", "Space", "Enter"], [], timing, 0.1, 0.2);var reduceMotion=false;var colors=[];colors[0]=["Sketchbook", "#ffffff", "#000000", "#808080", "#ff0000"];colors[1]=["Scratchpad", "#202020", "#ffffff", "#808080", "#ffd700"];colors[2]=["Golden Ticket", "#303030", "#b29700", "#8e7900", "#efe7d6"];colors[3]=["Ikaniko", "#1E2A26", "#7CA49B", "#267B75", "#C8EEE5"];colors[4]=["BackFlipped", "#223e32", "#b3dd52", "#04bf00", "#A7C06D"];var colorTheme=0;var audioEnabled=true;var freshState=true;var victory=false;var targetLevel=0;var dirtyRender=true;var previousScale=0;window.onresize=function(){canvas.width=canvas.clientWidth;canvas.height=canvas.clientHeight;dirtyRender=true;};canvas.width=canvas.clientWidth;canvas.height=canvas.clientHeight;var levelSolved=[];for(var i=0;i!=levels.length;i += 1){levelSolved[i]=0;}var amountOfLevelsSolved=0;loadGame();loadLevel(level);function gameLoop(){try{timing.update();horizontalInput.update();verticalInput.update();undoInput.update();confirmInput.update();  if(!victory&&!titleScreen){if(!menuOpened){if(verticalInput.fired){MovePlayer(0, verticalInput.delta);}if(horizontalInput.fired){MovePlayer(horizontalInput.delta, 0);}if(undoInput.fired==true&&undoStack.length!=0){audio(5);var stateToRestore=undoStack.pop();player=stateToRestore.player;boxes=stateToRestore.boxes;levelOffsetX=stateToRestore.xOff;levelOffsetY=stateToRestore.yOff;steps=steps.slice(0, -1);if(steps.length==0||steps.slice(-1)==" "){freshState=true;}else{freshState=false;}if(level==0){var lvl=hasLevelNode(player.x, player.y);setLevelName(lvl,1);};timeSinceLastAction=timeToCompleteTween;dirtyRender=true;}if(confirmInput.fired){if(timeSinceLevelStart >= timeToLoadLevel){var lvl=hasLevelNode(player.x, player.y);if(lvl!=null){targetLevel=levelNodes[lvl].target;victory=true;timeSinceLevelWon=0;audio(0);}}}}else{var items=5;if(level==0){items=4;}if(verticalInput.fired&&verticalInput.delta==1){menuSelection += 1;if(menuSelection >= items){menuSelection=0;}}else if(verticalInput.fired&&verticalInput.delta==-1){menuSelection -= 1;if(menuSelection < 0){menuSelection=items-1;}}else if(confirmInput.fired){switch(menuSelection){case 0:menuOpened=!menuOpened;audio(0, true);break;case 1: audioEnabled=!audioEnabled;if(audioEnabled){audio(7, true);}saveGame();break;case 2: reduceMotion=!reduceMotion;audio(2, true);saveGame();break;case 3: if(timeSinceLastThemeChange >= timeUntilChangableTheme){timeSinceLastThemeChange=0;colorTheme++;if(colorTheme >= colors.length){colorTheme=0;}dirtyRender=true;audio(2, true);}saveGame();break;case 4: loadLevel(0);audio(8, true);menuOpened=!menuOpened;}}}}timeSinceLastAction=M.min(timeSinceLastAction + timing.currentFrameLength, timeToCompleteTween);timeSinceUpdatedRenders=M.min(timeSinceUpdatedRenders + timing.currentFrameLength, timeToUpdateRenders);timeSinceLevelStart=M.min(timeSinceLevelStart + timing.currentFrameLength, timeToLoadLevel);timeSinceLevelWon=M.min(timeSinceLevelWon + timing.currentFrameLength, timeUntilLevelEnd);timeSinceLastThemeChange=M.min(timeSinceLastThemeChange + timing.currentFrameLength, timeUntilChangableTheme);timeSinceLastAudio=M.min(timeSinceLastAudio + timing.currentFrameLength, timeUntilPlayableAudio);timeSinceLevelNameChanged=M.min(timeSinceLevelNameChanged + timing.currentFrameLength, timeToDisplayLevelName);timeSinceMenuToggled=M.min(timeSinceMenuToggled + timing.currentFrameLength, timeToToggleMenu);if(titleScreen){timeSinceLevelStart=timeToLoadLevel * .5;}if(canvas.width < 700||canvas.height < 700){scale=40;}else if(canvas.width < 1000||canvas.height < 900){scale=55;}else{scale=70;}var alph=1;var localScale=scale;if(timeSinceLevelStart < timeToLoadLevel){alph=timeSinceLevelStart / timeToLoadLevel;localScale=(scale + 20) - 20 * EaseInOut(timeSinceLevelStart / timeToLoadLevel);}else if(timeSinceLevelWon < timeUntilLevelEnd&&level!=0){alph=1 - (timeSinceLevelWon / timeUntilLevelEnd);localScale=(scale - 50) + 50 * (1-EaseInOut(timeSinceLevelWon / timeUntilLevelEnd));}else if(timeSinceLevelWon < timeUntilLevelSelected&&level==0){alph=1 - (timeSinceLevelWon / timeUntilLevelSelected);localScale=(scale) - 20 * (EaseInOut(timeSinceLevelWon / timeUntilLevelSelected));}else if(((timeSinceLevelWon >= timeUntilLevelEnd&&level!=0)||(timeSinceLevelWon >= timeUntilLevelSelected&&level==0))&&victory){if(level==0){loadLevel(targetLevel);}else{if(level==levels.length-1){gameName="Victory! ";subTitle="Thank you for playing!";titleScreen=true;audio(9);}loadLevel(0);}alph=0;}if(reduceMotion){var localScale=scale;}var verHeight=gridHeight * localScale;var horWidth=gridWidth * localScale;var rerendered=false;if((!reduceMotion&&timeSinceUpdatedRenders >= timeToUpdateRenders)||localScale!=previousScale||dirtyRender){if(!reduceMotion&&timeSinceUpdatedRenders >= timeToUpdateRenders){roughSeed += 1;timeSinceUpdatedRenders=0;}rerendered=true;dirtyRender=false;if(localScale!=previousScale){playerCanvas.width=localScale;playerCanvas.height=localScale;wallCanvas.width=localScale+wallMargin;wallCanvas.height=localScale+wallMargin;boxCanvas.width=localScale+boxMargin;boxCanvas.height=localScale+boxMargin;rubbleCanvas.width=localScale+rubbleMargin;rubbleCanvas.height=localScale+rubbleMargin;targetCanvas.width=localScale+targetMargin;targetCanvas.height=localScale+targetMargin;}else{PlayerCtx.clearRect(0,0, playerCanvas.width, playerCanvas.height);PlayerCtx.beginPath();wallCtx.clearRect(0,0, wallCanvas.width, wallCanvas.height);wallCtx.beginPath(); boxCtx.clearRect(0,0, boxCanvas.width, boxCanvas.height);boxCtx.beginPath();rubbleCtx.clearRect(0,0, rubbleCanvas.width, rubbleCanvas.height);rubbleCtx.beginPath();targetCtx.clearRect(0,0, targetCanvas.width, targetCanvas.height);targetCtx.beginPath();}var size=0.8;roughPlayer.circle(localScale * .5, localScale * .5, localScale * size,{fill: colors[colorTheme][1], fillStyle: "solid", stroke: colors[colorTheme][2], strokeWidth: 1, seed: roughSeed});roughWall.rectangle(wallMargin * 0.5, wallMargin * 0.5,localScale, localScale,{stroke: colors[colorTheme][2], fill: colors[colorTheme][2], strokeWidth: 1, seed: roughSeed});var size=0.8;roughBox.rectangle(boxMargin * 0.5 + (1-size) * 0.5 * localScale, boxMargin * 0.5 + (1-size) * 0.5 * localScale,localScale * size, localScale * size,{stroke: colors[colorTheme][2], fill: colors[colorTheme][2], strokeWidth: 2, seed: roughSeed});var size=1.1;roughRubble.rectangle(rubbleMargin * 0.5 + (1-size) * 0.5 * localScale, rubbleMargin * 0.5 + (1-size) * 0.5 * localScale,localScale * size, localScale * size,{stroke: "none", fill: colors[colorTheme][2], fillStyle: "dots", fillWeight: localScale / 70, strokeWidth: 2, seed: roughSeed});var size=1.1;roughTarget.circle(localScale * 0.5 + targetMargin * 0.5, localScale * 0.5 + targetMargin * 0.5,localScale * size,{fillStyle: "zigzag", fill: colors[colorTheme][3], stroke: colors[colorTheme][2], strokeWidth: 1, seed: roughSeed});}if(favicon!=null&&!wroteFavicon){favicon.href=targetCanvas.toDataURL('image/png');wroteFavicon=true;}var shaking=(camShakeX!=0||camShakeY!=0);var reduceCamShake=2;if(camShakeX > 0){camShakeX=M.max(0, camShakeX - reduceCamShake)}else if(camShakeX < 0){camShakeX=M.min(0, camShakeX + reduceCamShake)}if(camShakeY > 0){camShakeY=M.max(0, camShakeY - reduceCamShake)}else if(camShakeY < 0){camShakeY=M.min(0, camShakeY + reduceCamShake)}var levelMargin=20;if(rerendered||timeSinceUpdatedRenders >= timeToUpdateRenders||timeSinceLastAction <= timeToCompleteTween * 2||alph!=1||shaking){if(localScale!=previousScale||dirtyRender){levelCanvas.width=horWidth+levelMargin;levelCanvas.height=verHeight+levelMargin;}else{levelCtx.clearRect(0,0, levelCanvas.width, levelCanvas.height);levelCtx.beginPath();}drawLevel(0, 0, gridWidth, gridHeight, localScale);rerendered=true;}if(rerendered||titleScreen){var shakeMultiplier=1;if(reduceMotion){shakeMultiplier=0}var cameraX=M.round(canvas.width * 0.5 - horWidth * 0.5 - levelMargin * 0.5 + camShakeX * 0.25 * shakeMultiplier);var cameraY=M.round(canvas.height * 0.5 - verHeight * 0.5 - levelMargin * 0.5+ camShakeY * 0.25 * shakeMultiplier); var clipOffset=10;var screenWidthRatio=M.ceil(((canvas.width - horWidth + clipOffset) / horWidth * 0.5));var screenHeightRatio=M.ceil(((canvas.height - verHeight + clipOffset) / verHeight * 0.5));if(levelOffsetX!=0){screenWidthRatio += 1}if(levelOffsetY!=0){screenHeightRatio += 1}var tweenOffsetX=levelOffsetX - prevLevelOffsetX * (1-EaseInOut(M.min(timeSinceLastAction / timeToCompleteTween, 1)));var tweenOffsetY=levelOffsetY - prevLevelOffsetY * (1-EaseInOut(M.min(timeSinceLastAction / timeToCompleteTween, 1)));ctx.globalAlpha=1;ctx.fillStyle=colors[colorTheme][1];ctx.fillRect(0,0,canvas.width, canvas.height);for(let y=screenHeightRatio;y >= 0;y--){for(let x=screenWidthRatio;x >= 0;x--){ctx.globalAlpha=M.max(0, alph - M.abs(y) * 0.1 - M.abs(x * 0.1));if(ctx.globalAlpha > 0){ctx.drawImage(levelCanvas,cameraX + horWidth * x + tweenOffsetX * localScale * y, cameraY + verHeight * y + tweenOffsetY * localScale * x);if(x!=0&&y!=0){ctx.drawImage(levelCanvas,cameraX + horWidth * (-x) + tweenOffsetX * localScale * (-y), cameraY + verHeight * (-y) + tweenOffsetY * localScale * (-x));}if(y!=0){ctx.drawImage(levelCanvas,cameraX + horWidth * (x) + tweenOffsetX * localScale * (-y), cameraY + verHeight * (-y) + tweenOffsetY * localScale * (x));}if(x!=0){ctx.drawImage(levelCanvas,cameraX + horWidth * (-x) + tweenOffsetX * localScale * (y), cameraY + verHeight * (y) + tweenOffsetY * localScale * (-x));}}}} const borderOffset=5;roughCanvas.rectangle(M.round(cameraX-borderOffset + camShakeX * 0.5 * shakeMultiplier), M.round(cameraY-borderOffset + camShakeY * 0.5 * shakeMultiplier),horWidth + borderOffset + levelMargin, verHeight + borderOffset + levelMargin,{stroke: colors[colorTheme][2], seed: roughSeed});ctx.globalAlpha=1;if(titleScreen||menuOpened){ctx.globalAlpha=0.4;ctx.fillStyle=colors[colorTheme][1];ctx.fillRect(-1,-1,canvas.width + 2, canvas.height + 2);ctx.globalAlpha=1;}if(!titleScreen){ctx.textAlign="left";ctx.font=40 + S;ctx.globalAlpha=EaseInOut(timeSinceLevelNameChanged / timeToDisplayLevelName);drawStroked(ctx, levelName, 40, canvas.height - 40);ctx.globalAlpha=1;}ctx.font=22 + S;ctx.fillStyle=colors[colorTheme][1];ctx.textAlign="center";ctx.textBaseline="middle";if(titleScreen){ctx.font=M.round(scale * 1.2) + S;ctx.textAlign="left";ctx.textBaseline="center";ctx.fillStyle="black";var txt=gameName;var textWidth=ctx.measureText(txt).width;var amount=M.ceil(canvas.width / textWidth)+1;txt=txt.repeat(amount);var startX=0;if(!reduceMotion){var startX=(timing.timePlaying % 5) / 5;}drawStroked(ctx, txt,-startX * textWidth,canvas.height * .5);ctx.font=M.round(scale * 0.5) + S;ctx.textAlign="center";drawStroked(ctx, subTitle,canvas.width * .5,canvas.height * .6);}else if(!menuOpened){if(!victory){roughCanvas.rectangle(-5, -5, 85, 85,{fill: colors[colorTheme][2], fillWeight: 4, stroke: "none", seed: M.round(roughSeed / 2)});ctx.fillText("[Esc]",50,60);if(level!=0){if(!freshState){ctx.globalAlpha=1;}else{ctx.globalAlpha=0.25;}roughCanvas.rectangle(canvas.width-160, canvas.height - 80, 100, 50,{fill: colors[colorTheme][2], fillWeight: 4, stroke: "none", seed: M.round(roughSeed / 2)});ctx.fillText("[R] Retry",canvas.width-110,canvas.height - 55);if(undoStack.length > 0){ctx.globalAlpha=1;}else{ctx.globalAlpha=0.25;}roughCanvas.rectangle(canvas.width-280, canvas.height - 80, 100, 50,{fill: colors[colorTheme][2], fillWeight: 4, stroke: "none", seed: M.round(roughSeed / 2) + 10});ctx.fillText("[Z] Undo",canvas.width-230,canvas.height - 55);}}}else{ctx.globalAlpha=1;var growth=1;if(!reduceMotion){var growth=EaseInOut(timeSinceMenuToggled / timeToToggleMenu);}var width=400 * growth;roughCanvas.rectangle(-5, -5, width + 5, 55 + 250 * growth,{fill: colors[colorTheme][2], fillWeight: 4, stroke: "none", seed: M.round(roughSeed / 2)});var textBase=50;var textOffset=50 * growth;ctx.globalAlpha=growth;roughCanvas.rectangle(20, textBase * 0.5 + menuSelection * textOffset, width - 40, textOffset,{fillStyle: "none", stroke: colors[colorTheme][1], seed: roughSeed});ctx.fillStyle=colors[colorTheme][1];ctx.textAlign="center";var txt="Audio: ";if(audioEnabled==true){txt += "ON";}else{txt += "OFF";}ctx.fillText(txt, width * 0.5,textBase + textOffset * 1);ctx.fillText("[Esc] Resume", width * 0.5,textBase);var txt="Reduce Motion: ";if(reduceMotion==true){txt += "ON";}else{txt += "OFF";}ctx.fillText(txt, width * 0.5,textBase + textOffset * 2);txt="Theme: "+colors[colorTheme][0] + " ("+(colorTheme+1) + "/" + colors.length + ")";ctx.fillText(txt, width * 0.5,textBase + textOffset * 3);if(level!=0){ctx.fillText("Back to Level Select", width * 0.5, textBase + textOffset * 4 );}else{ctx.font=16 + S;ctx.fillText("Game by Tom Hermans for js13k 2020", width * 0.5, textBase + textOffset * 3.8);ctx.fillText("rough - Copyright (c) 2019 Preet Shihn", width * 0.5, textBase + textOffset * 4.2);ctx.fillText("ZzFX - Copyright (c) 2019 Frank Force", width * 0.5, textBase + textOffset * 4.6);}ctx.globalAlpha=1;}} previousScale=localScale;window.requestAnimationFrame(gameLoop);}catch (e){console.error("Whoops! The game crashed.", e);   }};window.requestAnimationFrame(gameLoop);function drawLevel(rootX,rootY, gridWidth, gridHeight, localScale){function drawWrapped(object, drawFunction){drawFunction(0,0);if(autoScrollX||autoScrollY ){return;}if(object.x <= 0.5){var wrapY=((object.y + levelOffsetY + gridHeight) % gridHeight) - object.y;drawFunction(gridWidth * localScale, wrapY * localScale);}else if(object.x >= gridWidth-1.5){var wrapY=((object.y - levelOffsetY + gridHeight) % gridHeight) - object.y;drawFunction(-gridWidth * localScale, wrapY * localScale);}if(object.y <= 0.5){var wrapX=((object.x + levelOffsetX + gridWidth) % gridWidth) - object.x;drawFunction(wrapX * localScale, gridHeight * localScale);}else if(object.y >= gridHeight-1.5){var wrapX=((object.x - levelOffsetX + gridWidth) % gridWidth) - object.x;drawFunction(wrapX * localScale, -gridHeight * localScale);}}var off=10;var playerTween=tweenPlayer();if(undoStack.length > 0&&!reduceMotion){var lnt=steps.length;var last=steps.lastIndexOf(" ");var tot=lnt - last;var amt=Clamp(undoStack.length, 1, 9);amt=M.min(amt, tot);for(var i=0;i < amt;i += 1){var index=undoStack.length - amt + i;if(index < 0||index > undoStack.length){break;}var percent=1;if(index==undoStack.length-1){percent=timeSinceLastAction / timeToCompleteTween;};var blend=M.max(0.01, ((i + (percent)) / (amt)) * 0.25 - ((1 / amt * 0.25)));var clr=blendColors(colors[colorTheme][1], colors[colorTheme][3], blend);var p1={x: undoStack[index].player.x, y: undoStack[index].player.y};var p2={x: undoStack[index].player.x, y: undoStack[index].player.y};switch (steps[index].toLowerCase()){case "u": p1.y += 0.2;p2.y -= 1.2 * percent;break;case "d": p1.y -= 0.2;p2.y += 1.2 * percent;break;case "l": p1.x += 0.2;p2.x -= 1.2 * percent;break;case "r": p1.x += 0.2;p2.x += 1.2 * percent;break;}function drawLine(offsetX=0, offsetY=0){roughLevel.line(PosX(p1.x + .5)+offsetX, PosY(p1.y + .5) +offsetY, PosX(p2.x + .5) +offsetX, PosY(p2.y + .5) +offsetY,{strokeWidth: localScale * 0.4, stroke: clr, seed: roughSeed+i, roughness: 0.75});}drawWrapped(p1, drawLine);}}for(let i=0;i!=rubble.length;i++){levelCtx.drawImage(rubbleCanvas, PosX(rubble[i].x) - rubbleMargin * 0.5, PosY(rubble[i].y) - rubbleMargin * 0.5);}for(let i=0;i!=targets.length;i++){levelCtx.drawImage(targetCanvas, PosX(targets[i].x) - targetMargin * 0.5, PosY(targets[i].y) - targetMargin * 0.5);}for(let i=0;i!=gates.length;i++){if(gates[i].target <= amountOfLevelsSolved){levelCtx.globalAlpha=0.2;}else{levelCtx.globalAlpha=1;}levelCtx.drawImage(boxCanvas, PosX(gates[i].x) - boxMargin * 0.5, PosY(gates[i].y) - boxMargin * 0.5);}levelCtx.globalAlpha=1;for(let i=0;i!=walls.length;i++){levelCtx.drawImage(wallCanvas, PosX(walls[i].x) - wallMargin * 0.5, PosY(walls[i].y) - wallMargin * 0.5);}for(let i=0;i!=levelNodes.length;i++){levelCtx.drawImage(targetCanvas, PosX(levelNodes[i].x) - targetMargin * 0.5, PosY(levelNodes[i].y) - targetMargin * 0.5);}function drawPlayer(offsetX=0, offsetY=0){levelCtx.drawImage(playerCanvas, PosX(playerTween.x) + offsetX + camShakeX,PosY(playerTween.y) + offsetY + camShakeY);}drawWrapped(player, drawPlayer);for(let i=0;i!=boxes.length;i++){var boxTween=tweenBox(i);function drawBox(offsetX=0, offsetY=0){levelCtx.drawImage(boxCanvas, PosX(boxTween.x) - boxMargin * .5 + offsetX,PosY(boxTween.y) - boxMargin * 0.5 + offsetY);if(boxes[i].shift==1||boxes[i].shift==3){roughLevel.line(PosX(boxTween.x) + localScale * 0.2 + offsetX, PosY(boxTween.y) + localScale * 0.5 + offsetY,PosX(boxTween.x) + localScale * 0.8 + offsetX, PosY(boxTween.y) + localScale * 0.5 + offsetY,{stroke: colors[colorTheme][4], strokeWidth: localScale / 7, seed: roughSeed})}if(boxes[i].shift==2||boxes[i].shift==3){roughLevel.line(PosX(boxTween.x) + localScale * 0.5 + offsetX, PosY(boxTween.y) + localScale * 0.2 + offsetY,PosX(boxTween.x) + localScale * 0.5 + offsetX, PosY(boxTween.y) + localScale * 0.8 + offsetY,{stroke: colors[colorTheme][4], strokeWidth: localScale / 7, seed: roughSeed})}} drawWrapped(boxes[i], drawBox);}levelCtx.textAlign="center";levelCtx.textBaseline="middle";levelCtx.fillStyle=colors[colorTheme][2];for(let i=0;i!=levelNodes.length;i++){levelCtx.font=M.round(0.5 * localScale) + S;levelCtx.fillText(levels[levelNodes[i].target][0].nr.toString(), PosX(levelNodes[i].x) + targetCanvas.width * 0.5 - targetMargin * 0.5, PosY(levelNodes[i].y) - targetMargin * 0.5 + targetCanvas.height * 0.5); if(levelSolved[i+1]==2){levelCtx.font=M.round(0.4 * localScale)+ S;levelCtx.fillText("✓", PosX(levelNodes[i].x) + targetCanvas.width * 0.75 - targetMargin * 0.5, PosY(levelNodes[i].y) - targetMargin * 0.5 + targetCanvas.height * 0.75);}else if(levelSolved[i+1]==0){levelCtx.font="bold " + M.round(0.25 * localScale)+ S;levelCtx.fillText("!", PosX(levelNodes[i].x) + targetCanvas.width * 0.5 - targetMargin * 0.5, PosY(levelNodes[i].y) - targetMargin * 0.5 + targetCanvas.height * 0.8);}}levelCtx.font=M.round(0.4 * localScale)+ S;levelCtx.textAlign="center";levelCtx.textBaseline="middle";levelCtx.fillStyle=colors[colorTheme][2];for(let i=0;i!=gates.length;i++){if(gates[i].target <= amountOfLevelsSolved){levelCtx.globalAlpha=0.2;}else{levelCtx.globalAlpha=1;}drawStroked(levelCtx, amountOfLevelsSolved + "/" + gates[i].target, PosX(gates[i].x) + boxCanvas.width * 0.5 - boxMargin * 0.5, PosY(gates[i].y) - boxMargin * 0.5 + boxCanvas.height * 0.5)}levelCtx.globalAlpha=1;function tweenPlayer(){if(undoStack.length > 0){var lastState=undoStack[undoStack.length-1];var source=lastState.player;return tweenObject(player, source);}else{return({x: player.x, y: player.y});}}function tweenBox(id){if(undoStack.length > 0){var lastState=undoStack[undoStack.length-1];var source=lastState.boxes[id];return tweenObject(boxes[id], source);}else{return({x: boxes[id].x, y: boxes[id].y});}}function tweenObject(current, source){var percent=1-Clamp((timeSinceLastAction / timeToCompleteTween), 0, 1);if(percent!=0){var diffX=M.round(current.x - source.x);var diffY=M.round(current.y - source.y);if(diffX!=0&&diffY!=0){if(prevHorDelta!=0){diffX -= M.sign(diffX) * gridWidth;diffY=0;}else{diffY -= M.sign(diffY) * gridHeight;diffX=0;}}else if(M.abs(diffX) > 1){diffX -= M.sign(diffX) * gridWidth;}else if(M.abs(diffY) > 1){diffY -= M.sign(diffY) * gridHeight;}percent=EaseInOut(percent);return ({x: current.x - (diffX * percent), y: current.y - (diffY * percent)});}else{return({x: current.x, y: current.y});}}function PosX(val){return (rootX + off + val * localScale);}function PosY(val){return (rootY + off + val * localScale);}}function input(event){if(victory){return;}if(titleScreen){audio(0, true);titleScreen=false;return;}var key=event.key;dirtyRender=true;if(key=="Escape"&&timeSinceMenuToggled >= 0.1){menuOpened=!menuOpened;if(menuOpened){audio(7, true);}else{audio(0, true);}timeSinceMenuToggled=0;menuSelection=0;}if(!menuOpened){if(key=="r"||key=="R"){if(!freshState){audio(6);undoStack.push({player: player, boxes: boxes.slice(), xOff: levelOffsetX, yOff: levelOffsetY});loadLevel(level, false);}return;}else if(event.shiftKey&&key=="n"||key=="N"){loadLevel(M.min(level + 1, levels.length-1 ));return;}else if(event.shiftKey&&key=="b"||key=="B"){loadLevel(M.max(level - 1, 0 ));return;}}}function loadLevel(number, resetStack=true){level=number;var levelToLoad=levels[number].slice();var metadata=levelToLoad.shift();if(levelSolved[level]==0){levelSolved[level]=1;}saveGame(); player={x: 0, y: 0};walls.length=0;boxes.length=0;targets.length=0;levelNodes.length=0;rubble.length=0;gates.length=0;camShakeX=0;camShakeY=0;freshState=true;victory=false;setLevelName(level);if(levelSolved[level]==2&&level!=0){levelName += " ✓";}if(metadata.xOff){levelOffsetX=metadata.xOff;}else{levelOffsetX=0;}if(metadata.yOff){levelOffsetY=metadata.yOff;}else{levelOffsetY=0;}if(metadata.autoX){autoScrollX=metadata.autoX;}else{autoScrollX=0;}if(metadata.autoY){autoScrollY=metadata.autoX;}else{autoScrollY=0;}var placedPlayer=false;var levelsPlaced=null;if(metadata.levelSpread){var levelsPlaced=metadata.levelSpread.slice();}var gatesPlaced=0;function checkPlayer(x, y, lvl){if(lvl==targetLevel&&!placedPlayer){player={x: x, y: y};placedPlayer=true;levelName=levels[targetLevel][0].nr+": "+levels[targetLevel][0].name + " - [Space] to enter";timeSinceLevelNameChanged=0;}}gridHeight=levelToLoad.length;gridWidth=0;for(let y=0;y < gridHeight;y++){gridWidth=M.max(gridWidth, levelToLoad[y].length);for(let x=0;x < levelToLoad[y].length;x++){var str=levelToLoad[y].substring(x,x+1).toLowerCase();switch (str){case "p": if(!placedPlayer){player={x: x, y: y};}break;case "#": walls.push({x: x, y: y});break;case "b": boxes.push({x: x, y: y, shift: 0});break;case "-": boxes.push({x: x, y: y, shift: 1});break;case "|": boxes.push({x: x, y: y, shift: 2});break;case "+": boxes.push({x: x, y: y, shift: 3});break;case "t": targets.push({x: x, y: y});break;case "1": levelNodes.push({x: x, y: y, target: levelsPlaced[0]}); checkPlayer(x, y, levelsPlaced[0]);levelsPlaced[0]++;break;case "2": if(amountOfLevelsSolved < metadata.gates[1]){targets.push({x: x, y: y});break;}levelNodes.push({x: x, y: y, target: levelsPlaced[1]}); checkPlayer(x, y, levelsPlaced[1]);levelsPlaced[1]++;break;case "3": if(amountOfLevelsSolved < metadata.gates[2]){targets.push({x: x, y: y});break;}levelNodes.push({x: x, y: y, target: levelsPlaced[2]}); checkPlayer(x, y, levelsPlaced[2]);levelsPlaced[2]++;break;case "4": if(amountOfLevelsSolved < metadata.gates[3]){targets.push({x: x, y: y});break;}levelNodes.push({x: x, y: y, target: levelsPlaced[3]}); checkPlayer(x, y, levelsPlaced[3]);levelsPlaced[3]++;break;case "r": rubble.push({x: x, y: y});break;case "g": gates.push({x: x, y: y, target: metadata.gates[gatesPlaced]});gatesPlaced++;}}}if(resetStack){undoStack=[];steps="";timeSinceLevelStart=0;timeSinceLevelWon=timeUntilLevelEnd;}else{steps += " ";}}function wrapCoords(newX, newY){function wrapX(){if(newX >= gridWidth){newX -= gridWidth;newY -= levelOffsetY; return true;}else if(newX < 0){newX += gridWidth;newY += levelOffsetY; return true;}return false;}function wrapY(){if(newY >= gridHeight){newY -= gridHeight;newX -= levelOffsetX; return true;}else if(newY < 0){newY += gridHeight;newX += levelOffsetX; return true;}return false;}var wrappedOnX=wrapX();var wrappedOnY=wrapY();if(!wrappedOnX){wrapX();}return{x: newX, y: newY, wrapped: (wrappedOnX||wrappedOnY)}}function hasThing(array, x, y){for(let i=0;i!=array.length;i++){if(array[i].x==x&&array[i].y==y){return i;}}return null;}function hasWall(x, y){return hasThing(walls, x, y)}function hasBox(x, y){return hasThing(boxes, x, y)}function hasTarget(x, y){return hasThing(targets, x, y)}function hasLevelNode(x, y){return hasThing(levelNodes, x, y)}function hasRubble(x, y){return hasThing(rubble, x, y)}function hasClosedGate(x, y){var gate=hasThing(gates, x, y);if(gates[gate]!=null){if(gates[gate].target <= amountOfLevelsSolved){return null;}}return gate;}function even(val){return ((val % 2)==0)}function EaseInOut(t){return(t*(2-t));}function drawStroked(ctx, text, x, y){ctx.miterLimit=2;ctx.strokeStyle=colors[colorTheme][2];ctx.lineWidth=8;ctx.strokeText(text, x, y);ctx.fillStyle=colors[colorTheme][1];ctx.fillText(text, x, y);}function MovePlayer(horDelta, verDelta){var dir="";if(horDelta==-1){dir="l"}else if(horDelta==1){dir="r"}else if(verDelta==1){dir="d"}else if(verDelta==-1){dir="u"}else{return;}if(horDelta!=0||verDelta!=0){undoStack.push({player: player, boxes: boxes.slice(), xOff: levelOffsetX, yOff: levelOffsetY});var movementResolved=false;var boxPushed=false;prevLevelOffsetX=0;prevLevelOffsetY=0;var target=wrapCoords(player.x + horDelta, player.y + verDelta);var targetX=target.x;var targetY=target.y;let foundBox=hasBox(targetX, targetY);if(foundBox !== null){var boxTarget=wrapCoords(targetX + horDelta, targetY + verDelta);let boxTargetX=boxTarget.x;let boxTargetY=boxTarget.y;if(hasWall(boxTargetX, boxTargetY) === null&&hasBox(boxTargetX, boxTargetY) === null&&hasRubble(boxTargetX, boxTargetY) === null){boxes[foundBox]={x: boxTargetX, y: boxTargetY, shift: boxes[foundBox].shift};player={x: targetX, y: targetY};movementResolved=true;boxPushed=true;if(boxes[foundBox].shift!=0){if(boxes[foundBox].shift==1||boxes[foundBox].shift==3){ShiftX(horDelta);}if(boxes[foundBox].shift==2||boxes[foundBox].shift==3){ShiftY(verDelta);}}}}else if(hasWall(targetX, targetY) === null&&hasClosedGate(targetX, targetY) === null){player={x: targetX, y: targetY};movementResolved=true;}}if(movementResolved){if(!boxPushed){steps += dir;}else{steps += dir.toUpperCase();}timeSinceLastAction=0;prevHorDelta=horDelta;freshState=false;if(level==0){var lvl=hasLevelNode(player.x, player.y);setLevelName(lvl,1);}if(autoScrollX){ShiftX(autoScrollX);}var hasWon=true;if(boxPushed&&targets.length > 0){for(let i=0;i!=targets.length;i++){if(hasBox(targets[i].x, targets[i].y) === null){hasWon=false;break;}}}else{hasWon=false;}if(hasWon){if(levelSolved[level]!=2){levelSolved[level]=2;amountOfLevelsSolved++;}saveGame();audio(4, true);victory=true;timeSinceLevelWon=0;}else{if(boxPushed){if(prevLevelOffsetX!=0||prevLevelOffsetY!=0){audio(3);}else{audio(10);}}else{audio(2);}}}else{if(horDelta!=0||verDelta!=0){audio(1);undoStack.pop();}camShakeX=horDelta * 12;camShakeY=verDelta * 12;}function ShiftX(horDelta){if(levelOffsetY==0){levelOffsetX -= horDelta;prevLevelOffsetX=-horDelta;timeSinceLastAction=0;if(levelOffsetX > gridWidth * 0.5){levelOffsetX -= gridWidth;}else if(levelOffsetX < -gridWidth * 0.5){levelOffsetX += gridWidth;}}else{}}function ShiftY(verDelta){if(levelOffsetX==0){levelOffsetY -= verDelta;prevLevelOffsetY=-verDelta;timeSinceLastAction=0;if(levelOffsetY >= gridHeight * 0.5){levelOffsetY -= gridHeight;}else if(levelOffsetY <= -gridHeight * 0.5){levelOffsetY += gridHeight;}}else{}}}function audio(soundID, alwaysPlay=false){if(!audioEnabled){return;}if(timeSinceLastAudio >= timeUntilPlayableAudio||alwaysPlay){if(!alwaysPlay){timeSinceLastAudio=0;}switch (soundID){case 0: zzfx(...[,.3,176,.02,,.08,3,.4,-0.7,-21,-127,.01,.05,,,,.38,,.03]);break;case 1: zzfx(...[,.3,220,.02,,.08,3,.4,-0.7,-21,-127,.01,.05,,,,.38,,.03]);case 2: zzfx(...[.6,.1,176,.02,,.01,3,.4,-0.7,-21,-127,.01,.05,,,,.1,,.02]);break;case 10: zzfx(...[.5,.1,220,.02,,.01,3,.4,-0.7,-21,-127,.01,.05,,,,.1,,.02]);break;case 3: zzfx(...[.45,.1,250,.02,,.01,3,.4,-0.7,-21,-127,.01,.05,,,.1,.1,,.02]);break;case 4: zzfx(...[.6,,934,.12,.38,.93,1,.27,,.4,-434,.08,.2,.1,,.1,.17,.55,1,.46]);break;case 5:zzfx(...[,,110,,,,1,1.82,,.1,,,,.1,,.1,.01,.7,.02,.15]);break;case 6: zzfx(...[,,283,.02,,.11,,.38,,,,,.07,,,.1,.08,.63,.02]);break;case 7: zzfx(...[,.02,1638,,.05,.17,1,,,,490,.09,,,,.1,.05,.5,.03]);break;case 8: zzfx(...[,,98,.08,.18,.02,2,2.47,36,.5,,,.04,.1,,.9,.44,,.04]);break;case 9: zzfx(...[,,525,.18,.28,.17,1,1.24,8.3,-9.7,-151,.03,.06,,,,,.93,.02,.14]);}}}function saveGame(){var ls=window.localStorage;var levelsSaved="";for (var i=1;i!=levelSolved.length;i += 1){if(levelSolved[i]==2){levelsSaved += "t";}else if(levelSolved[i]==1){levelsSaved += "f";}else{levelsSaved += "n";}}ls.setItem("enf-l",levelsSaved);ls.setItem("enf-c",colorTheme);ls.setItem("enf-a", audioEnabled);ls.setItem("enf-r", reduceMotion);ls.setItem("enf-v", 1);if(targetLevel!=0){ls.setItem("enf-t", targetLevel);}}function loadGame(){var ls=window.localStorage;var loadedValue=ls.getItem("enf-l"); if(loadedValue!=null){for (var i=1;i!=levelSolved.length;i += 1){if(loadedValue[i-1]=="t"){levelSolved[i]=2;amountOfLevelsSolved++;}else if(loadedValue[i-1]=="f"){levelSolved[i]=1;}}}var loadedValue=parseInt(ls.getItem("enf-c", 0));if(loadedValue >= 0&&loadedValue < colors.length){colorTheme=loadedValue;}var loadedValue=parseInt(ls.getItem("enf-t", 0));if(loadedValue >= 0&&loadedValue < levels.length){targetLevel=loadedValue;}var loadedValue=ls.getItem("enf-a");if(loadedValue=="false"){audioEnabled=false;}var loadedValue=ls.getItem("enf-r");reduceMotion=loadedValue=="true";}function setLevelName(lvl, offset=0){var prevName=levelName;if(level!=0&&!levelSolved.includes(2)){levelName="Push the box to the goal!";}else if(lvl!=null&&lvl + offset!=0){levelName=levels[lvl + offset][0].nr+": "+levels[lvl + offset][0].name;if(level==0){levelName += " - [Space] to enter";}}else if(!levelSolved.includes(2)){levelName="WASD/Arrow Keys to move";}else{levelName="";}if(prevName!=levelName){timeSinceLevelNameChanged=0;}}function blendColors(colorA, colorB, amount){const [rA, gA, bA]=colorA.match(/\w\w/g).map((c) => parseInt(c, 16));const [rB, gB, bB]=colorB.match(/\w\w/g).map((c) => parseInt(c, 16));const r=M.round(rA + (rB - rA) * amount).toString(16).padStart(2, '0');const g=M.round(gA + (gB - gA) * amount).toString(16).padStart(2, '0');const b=M.round(bA + (bB - bA) * amount).toString(16).padStart(2, '0');return '#' + r + g + b;}</script>
    </body></html>