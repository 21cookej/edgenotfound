<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>TOMATO üçÖ</title>
		<link rel="stylesheet" type="text/css" href="style.css">
		<script src="tomato.js"></script>
		<script src="rough.js"></script>
	</head>
	<body>
		<canvas id="canvas" width="100" height="100"> </canvas>
		<script>
			var scale = 70;
			var roughSeed = 1;

			const timing = new Timing((1/ 10), (1 / 30))

			const canvas = document.getElementById("canvas");
			const ctx = canvas.getContext("2d");
			const roughCanvas = rough.canvas(canvas);

			const levelCanvas = document.createElement("canvas");
			const levelCtx = levelCanvas.getContext("2d");
			const roughLevel = rough.canvas(levelCanvas);

			const wallCanvas = document.createElement("canvas");
			const wallCtx = wallCanvas.getContext("2d");
			const roughWall = rough.canvas(wallCanvas);
			const wallMargin = 10;

			let undoStack = [];

			var mousePos = new Vector2(0,0);

			const obj = {
				EMPTY: 0,
				PLAYER: 1,
				WALL: 2,
				BOX: 3,
				TARGET: 4,
			}

			var levels = [];
			levels[0] = [
				{name: "QQQ"},
				[2,2,2,0],
				[0,3,1,0],
				[0,2,0,0],
				[0,0,0,4],
			]
			levels[1] = [
				{name: "QQQ"},
				[0,0,2,0,0],
				[0,0,4,3,0],
				[0,2,0,2,0],
				[0,3,4,0,0],
				[0,0,2,0,0]
			]
			levels[2] = [
				{name: "QQQ"},
				[2,2,3,2,2],
				[2,4,0,4,2],
				[3,0,1,0,0],
				[2,0,3,4,2],
				[2,2,0,2,2]
			]
			levels[3] = [ //Decent easy level, rdddlldddlruuuulldrllddru (25)
				{name: "QQQ"},
				[0,0,2,0],
				[1,0,2,0],
				[0,4,3,4],
				[2,3,0,3],
				[0,4,3,4]
			]
			levels[4] = [
				{name: "Continuous Corridor"},
				[0,0,0,0,0,0,0,0,0],
				[2,2,2,0,0,0,0,0,0],
				[0,0,2,0,0,0,0,0,0],
				[0,0,0,0,0,0,0,0,0],
				[0,0,2,0,0,0,0,0,0],
				[2,2,2,2,2,2,2,2,2]
			]
			levels[5] = [
				{name: "Twisted Terrace", xOff: 3},
				[3,0,0,0,0,0],
				[0,2,2,0,2,2],
				[0,2,0,4,0,2],
				[3,3,4,1,4,3],
				[0,2,0,4,0,2],
				[0,2,2,0,2,2]
			]
			levels[6] = [
				{name: "Test", xOff: 2},
				[0,2,2,2,2,2],
				[0,1,0,0,0,0],
				[0,0,3,0,0,0],
				[0,0,0,0,0,0],
				[0,2,2,2,2,2],
				[0,0,0,0,0,0],
				[0,0,0,4,0,0],
				[0,0,0,0,0,0]
			]
			var level = 6;

			var levelName = "Test";
			var levelOffsetX = 0;
			var levelOffsetY = 0; //QQQ Can't both be non-zero, might implement this later

			onkeydown = e => {
				if (e.key == "ArrowDown" || e.key == "ArrowUp" || e.key == " " || e.key == "Backspace")
				{
					e.preventDefault();
				}

				input(e.key);
			};

			canvas.addEventListener('mousemove', function(evt) {
				var rect = canvas.getBoundingClientRect();
				mousePos = new Vector2(evt.clientX - rect.left, evt.clientY - rect.top);
				//console.log(mousePos);
			}, false);

			//Init level
			var gridHeight = levels[level].length;
			var gridWidth = levels[level][0].length;

			var player = {x: 0, y: 0};
			var walls = [];
			var boxes = [];
			var targets = [];

			var steps = "";

			var timeSinceLastAction = 0;
			var timeToCompleteTween = 1000; //in milliseconds

			loadLevel(level);

			var gameLoop = setInterval(() => {
				try {
					//Init
					timing.update();

					timeSinceLastAction += timing.currentFrameLength;

					canvas.width = canvas.clientWidth;
					canvas.height = canvas.clientHeight;

					//Render
					roughSeed = Math.round(timing.timePlaying) + 1;

					if (canvas.width < 500) {
						scale = 40;
					} else {
						scale = 70;
					}

					var localScale = scale;
					var verHeight = gridHeight * localScale;
					var horWidth = gridWidth * localScale;

					wallCanvas.width = localScale+wallMargin;
					wallCanvas.height = localScale+wallMargin;
					roughWall.rectangle(wallMargin * 0.5, wallMargin * 0.5, scale, scale, {fill: "solid", strokeWidth: 1, seed: roughSeed});

					var levelMargin = 20; //In pixels, positive
					levelCanvas.width = horWidth+levelMargin;
					levelCanvas.height = verHeight+levelMargin;

					var cameraX = canvas.width * 0.5 - horWidth * 0.5;
					var cameraY = canvas.height * 0.5 - verHeight * 0.5;

					const borderOffset = 5;
					roughCanvas.rectangle(cameraX-borderOffset, cameraY-borderOffset, 
						horWidth + borderOffset + levelMargin, verHeight + borderOffset + levelMargin, {seed: roughSeed});

					drawLevel(roughLevel, 0, 0, gridWidth, gridHeight, localScale, 1, roughSeed);
					
					var clipOffset = 10; //In pixels, positive
					var screenWidthRatio = Math.ceil(((canvas.width - horWidth + clipOffset) / horWidth * 0.5));
					var screenHeightRatio = Math.ceil(((canvas.height - verHeight + clipOffset) / verHeight * 0.5));

					if (levelOffsetX != 0) {screenWidthRatio += 1}
					if (levelOffsetY != 0) {screenHeightRatio += 1}

					//console.log("w: "+screenWidthRatio + "h: "+screenHeightRatio);

					for(let y = -screenHeightRatio; y <= screenHeightRatio; y++) {
						for(let x = -screenWidthRatio; x <= screenWidthRatio; x++) {
							if (x != 0 || y != 0) 
							{
								ctx.globalAlpha = 1 - Math.abs(y) * 0.1 - Math.abs(x * 0.1);
								if (ctx.globalAlpha > 0) {
									ctx.drawImage(levelCanvas, 
									cameraX + horWidth * x + levelOffsetX * scale * y,
									cameraY + verHeight * y + levelOffsetY * scale * x);
								}
							}
						}
					}

					ctx.globalAlpha = 1;
					ctx.drawImage(levelCanvas, cameraX, cameraY);

					drawStroked(levelName, 40, canvas.height - 40)

					//QQQ
					roughCanvas.rectangle(50,50,canvas.width - 100, 50, {fill: "solid", fillWeight: 4, fillStyle: "white", seed: 1});
					ctx.font = "24px sans-serif";
					ctx.fillStyle = "white";
					ctx.fillText("Todo: Level Select, Puzzles, Tweens, More block types, Keep under 13KB, Optimization. Deadline 13 September!",60,80)
				}
				catch (e) {
						console.error("Whoops! Something went wrong and the game crashed. The cause:", e)
						console.log("Here's some extra info to help resolve the issue. (It might contain some personal information.)")
						console.log("Your user agent is:",navigator.userAgent)
						console.log("Are your cookies enabled?",navigator.cookieEnabled)
						console.log("Are you online?",navigator.onLine)
						console.log("The language your browser is set to:",navigator.language)
						
						const canvas = document.getElementById("canvas");
						if (canvas) {
							console.log("Size of the canvas:",{width: canvas.width, height: canvas.height})
						}

						clearInterval(gameLoop);
					}
			}, (1 / 60) * 1000);

			function drawLevel(rghCanvas,rootX,rootY, gridWidth, gridHeight, localScale, lineWidth, seed) {

				var off = 10;
				var hscl = localScale * 0.5 //Half scale

				//Player
				var playerTween = tweenPlayer();

				drawWrapped(player, drawPlayer);

				function drawPlayer(offsetX = 0, offsetY = 0) {
					rghCanvas.circle(PosX(playerTween.x) + hscl + offsetX, PosY(playerTween.y) + hscl + offsetY, localScale * 0.8, 
						{strokeWidth: 1 * lineWidth, seed: seed});
				}

				function drawWrapped(object, drawFunction) {

					drawFunction()

					if (object.x == 0) {
						drawFunction(gridWidth * localScale, levelOffsetY * localScale)
					} else if (object.x == gridWidth-1) {
						drawFunction(-gridWidth * localScale, -levelOffsetY * localScale)
					} 
					
					if (object.y == 0) {
						drawFunction(levelOffsetX * localScale, gridHeight * localScale)
					} else if (object.y == gridHeight-1) {
						drawFunction(-levelOffsetX * localScale, -gridHeight * localScale)
					}
				}

				//Boxes
				for(let i = 0; i != boxes.length; i++) {
					var boxTween = tweenBox(i);
					
					drawWrapped(boxes[i], drawBox)

					function drawBox(offsetX = 0, offsetY = 0) {
						rghCanvas.rectangle(PosX(boxTween.x) + offsetX, PosY(boxTween.y) + offsetY, 
							localScale ,localScale, {fill: "dots", strokeWidth: 2 * lineWidth, seed: seed});
					}

				}

				//Target
				for(let i = 0; i != targets.length; i++) {
					rghCanvas.circle(PosX(targets[i].x) + localScale * 0.5, PosY(targets[i].y) + localScale * 0.5, localScale * 1.1, {fillStyle: "zigzag", fill: "#888", strokeWidth: 1 * lineWidth, seed: seed});
				}

				//Walls
				for(let i = 0; i != walls.length; i++) {
					var even = (walls[i].x + walls[i].y);
					levelCtx.drawImage(wallCanvas, PosX(walls[i].x) - wallMargin * 0.5, PosY(walls[i].y) - wallMargin * 0.5);
				}

				function tweenPlayer() {
					if (undoStack.length > 0) {
						var lastState = undoStack[undoStack.length-1];
						var source = lastState.player;
						return tweenObject(player, source);
					}
					else {
						return({x: player.x, y: player.y});
					}
				}

				function tweenBox(id) {
					if (undoStack.length > 0) {
						var lastState = undoStack[undoStack.length-1];
						var source = lastState.boxes[id];
						return tweenObject(boxes[id], source);
					}
					else {
						return({x: boxes[id].x, y: boxes[id].y});
					}
				}

				function tweenObject(current, source) {
					if (timeSinceLastAction < timeToCompleteTween) {
						var diffX = Math.round(current.x - source.x);
						var diffY = Math.round(current.y - source.y);

						if (diffX != 0 && diffY != 0) {
							if (Math.abs(diffX) >= Math.abs(diffY)) {
								diffX -= Math.sign(diffX) * gridWidth;
								diffY = 0;
							} else {
								diffY -= Math.sign(diffX) * gridHeight;
								diffX = 0;
							}
						} else if (Math.abs(diffX) > 1) {
							diffX -= Math.sign(diffX) * gridWidth;
						} else if (Math.abs(diffY) > 1) {
							diffY -= Math.sign(diffY) * gridHeight;
						}

						var percent = 1-Clamp((timeSinceLastAction / timeToCompleteTween) * 1000, 0, 1)
						return ({x: current.x - (diffX * percent), y: current.y - (diffY * percent)});
					} else {
						return({x: current.x, y: current.y});
					}
				}

				function PosX(val) {
					return (rootX + off + val * localScale);
				}

				function PosY(val) {
					return (rootY + off + val * localScale);
				}
			}

			function input(key) {

				if (key == "r") {
					loadLevel(level, false);
					return;
				} else if (key == "+") {
					loadLevel(Math.min(level + 1, levels.length-1 ))
					return;
				} else if (key == "-") {
					loadLevel(Math.max(level - 1, 0 ))
					return;
				} else if (key == "z") {
					if (undoStack.length != 0) {
						var stateToRestore = undoStack.pop();

						player = stateToRestore.player;
						boxes = stateToRestore.boxes;

						steps = steps.slice(0, -1);

						console.warn("Popped the undo stack, remaining entries:", undoStack.length)
					}
					return;
				}

				var dir = "";

				var horDelta = 0; 
				if (key == "ArrowLeft" || key == "a" || key == "q") {horDelta = -1; dir = "l"}
				if (key == "ArrowRight" || key == "d") {horDelta = 1; dir = "r"}

				var verDelta = 0;
				if (key == "ArrowDown" || key == "s") {verDelta = 1; dir = "d"}
				if (key == "ArrowUp" || key == "w") {verDelta = -1; dir = "u"}

				console.log("------");

				if (horDelta != 0 || verDelta != 0) {
					undoStack.push({player: player, boxes: boxes.slice()}) //Other objects can't move, so aren't stored.

					var movementResolved = false;

					var target = wrapCoords(player.x + horDelta, player.y + verDelta);
					var targetX = target.x;
					var targetY = target.y;

					console.log("x:"+player.x+"y:"+player.y+" tx:"+targetX+"ty:"+targetY);

					let foundBox = hasBox(targetX, targetY);
					console.log("fb: "+foundBox);
					if (foundBox !== null) {
						var boxTarget = wrapCoords(targetX + horDelta, targetY + verDelta)
						let boxTargetX = boxTarget.x;
						let boxTargetY = boxTarget.y;

						//console.log("bx: "+boxTargetX+" by:"+boxTargetY);
						//console.log("hasWall:",hasWall(boxTargetX, boxTargetY))
						if (hasWall(boxTargetX, boxTargetY) === null && hasBox(boxTargetX, boxTargetY) === null) {
							boxes[foundBox] = {x: boxTargetX, y: boxTargetY}
							player = {x: targetX, y: targetY}
							movementResolved = true;
						} else {
							console.log("Movement not resolved","Could not push box")
						}
					}
					else if (hasWall(targetX, targetY) === null) {
						player = {x: targetX, y: targetY}
						movementResolved = true;
					} else {
						console.log("Movement not resolved","Something was in the way")
					}
				}

				if (movementResolved) {
					steps += dir;
					timeSinceLastAction = 0;

					//Check if won
					var victory = true;
					for(let i = 0; i != targets.length; i++) {
						if (hasBox(targets[i].x, targets[i].y) === null) {
							victory = false; break;
						}
					}

					if (victory) {
						console.warn("Victory!",steps + " (" + steps.length + ")");
					}
				} else {
					undoStack.pop(); //Nothing changed, so discard Undo state.
				}
			}

			function loadLevel(number, resetStack = true) {
				level = number;

				var lvl = levels[number].slice()
				var metadata = lvl.shift();

				gridHeight = lvl.length;
				gridWidth = lvl[0].length;
				
				player = {x: 0, y: 0};
				walls = [];
				boxes = [];
				targets = [];

				if (metadata.name) {
					levelName = metadata.name;
				} else {
					levelName = "";
				}

				if (metadata.xOff) {
					levelOffsetX = metadata.xOff;
				} else {
					levelOffsetX = 0;
				}

				if (metadata.yOff) {
					levelOffsetY = metadata.yOff;
				} else {
					levelOffsetY = 0;
				}

				for(let y = 0; y < gridHeight; y++) {
					for(let x = 0; x < gridWidth; x++) {
						if (lvl[y][x]) {
							switch (lvl[y][x]) {
								case obj.PLAYER:
									this.player = {x: x, y: y}
									break;
								case obj.WALL:
									walls.push({x: x, y: y})
									break;
								case obj.BOX:
									boxes.push({x: x, y: y})
									break;
								case obj.TARGET:
									targets.push({x: x, y: y})
									break;
							}
						}
					}
				}

				if (resetStack) {
					undoStack = [];
					steps = "";
				} else {
					steps += "!";
				}
			}

			function wrapCoords(newX, newY) {
				function wrapX() {
					if (newX >= gridWidth) {
						newX -= gridWidth;
						newY -= levelOffsetY;
						//console.log("X-");
						return true;
					} else if (newX < 0) {
						newX += gridWidth;
						newY += levelOffsetY;
						//console.log("X+");
						return true;
					}
					return false;
				}

				function wrapY() {
					if (newY >= gridHeight) {
						newY -= gridHeight;
						newX -= levelOffsetX;
						//console.log("Y-");
						return true;
					} else if (newY < 0) {
						newY += gridHeight;
						newX += levelOffsetX;
						//console.log("Y+");
						return true;
					}
					return false;
				}

				var wrappedOnX = wrapX();
				var wrappedOnY = wrapY();
				if (!wrappedOnX) {
					wrapX();
				}
				/*if (!wrappedOnY) {
					wrapY();
				}*/

				return {x: newX, y: newY}
			}

			function hasThing(array, x, y) {
				for(let i = 0; i != array.length; i++) {
					if (array[i].x == x && array[i].y == y) {
						return i;
					}
				}
				return null;
			}

			function hasWall(x, y) {
				return hasThing(walls, x, y)
			}

			function hasBox(x, y) {
				return hasThing(boxes, x, y)
			}

			function hasTarget(x, y) {
				return hasThing(targets, x, y)
			}

			function even(val) {
				return ((val % 2) == 0)
			}

			//From https://stackoverflow.com/questions/13627111/drawing-text-with-an-outer-stroke-with-html5s-canvas
			function drawStroked(text, x, y) {
				ctx.miterLimit = 2;
				ctx.font = '40px sans-serif';
				ctx.strokeStyle = 'black';
				ctx.lineWidth = 8;
				ctx.strokeText(text, x, y);
				ctx.fillStyle = 'white';
				ctx.fillText(text, x, y);
			}
		</script>
	</body>
</html>