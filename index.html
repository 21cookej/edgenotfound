<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>TOMATO üçÖ</title>
		<link rel="stylesheet" type="text/css" href="style.css">
		<script src="tomato.js"></script>
		<script src="rough.js"></script>
	</head>
	<body>
		<canvas id="canvas" width="100" height="100"> </canvas>
		<script>
			const timing = new Timing((1/ 10), (1 / 30))

			const canvas = document.getElementById("canvas");
			const ctx = canvas.getContext("2d");
			const roughCanvas = rough.canvas(canvas);

			const levelCanvas = document.createElement("canvas");
			const levelCtx = levelCanvas.getContext("2d");
			const roughLevel = rough.canvas(levelCanvas);

			//const hb = new HitboxSquare(100,150, 80);

			//const moveHor = new InputHandler(["KeyD", "ArrowRight"], ["KeyA", "ArrowLeft"], timing, 250)
			//const moveVer = new InputHandler(["KeyS", "ArrowDown"], ["KeyW", "ArrowUp"], timing, 250);

			const scale = 70;

			var mousePos = new Vector2(0,0);

			const obj = {
				EMPTY: 0,
				PLAYER: 1,
				WALL: 2,
				BOX: 3,
				TARGET: 4,
			}

			var levels = [];
			levels[0] = [
				[2,2,2,0],
				[0,3,1,0],
				[0,2,0,0],
				[0,0,0,4],
			]
			levels[1] = [
				[0,0,2,0,0],
				[0,0,4,3,0],
				[0,2,0,2,0],
				[0,3,4,0,0],
				[0,0,2,0,0]
			]
			levels[2] = [
				[2,2,3,2,2],
				[2,4,0,4,2],
				[3,0,1,0,0],
				[2,0,3,4,2],
				[2,2,0,2,2]
			]
			levels[3] = [ //Decent easy level, rdddlldddlruuuulldrllddru (25)
				[0,0,2,0],
				[1,0,2,0],
				[0,4,3,4],
				[2,3,0,3],
				[0,4,3,4]
			]
			var level = 3;

			var levelName = "Test";
			var levelOffsetX = 0;
			var levelOffsetY = 0; 

			onkeydown = e => {
				if (e.key == "ArrowDown" || e.key == "ArrowUp" || e.key == " " || e.key == "Backspace")
				{
					e.preventDefault();
				}

				input(e.key);
			};

			canvas.addEventListener('mousemove', function(evt) {
				var rect = canvas.getBoundingClientRect();
				mousePos = new Vector2(evt.clientX - rect.left, evt.clientY - rect.top);
				//console.log(mousePos);
			}, false);

			//Init level
			var gridHeight = levels[level].length;
			var gridWidth = levels[level][0].length;

			var player = {x: 0, y: 0};
			var walls = [];
			var boxes = [];
			var targets = [];

			var steps = "";

			loadLevel(level);

			var gameLoop = setInterval(() => {
				try {
					//Init
					timing.update();

					canvas.width = canvas.clientWidth;
					canvas.height = canvas.clientHeight;

					//Render
					var roughSeed = Math.round(timing.timePlaying) + 1

					var localScale = scale;
					var verHeight = gridHeight * localScale;
					var horWidth = gridWidth * localScale;

					var levelMargin = 20
					levelCanvas.width = horWidth+levelMargin;
					levelCanvas.height = verHeight+levelMargin;

					var cameraX = canvas.width * 0.5 - horWidth * 0.5 - levelMargin * 0.5;
					var cameraY = canvas.height * 0.5 - verHeight * 0.5 - levelMargin * 0.5;

					const borderOffset = 5;
					roughCanvas.rectangle(cameraX-borderOffset, cameraY-borderOffset, horWidth + borderOffset + levelMargin, verHeight + borderOffset + levelMargin, {seed: roughSeed});

					drawLevel(roughLevel, 0, 0, gridWidth, gridHeight, localScale, 1, roughSeed);
					
					for(let y = -2; y <= 2; y++) {
						for(let x = -3; x <= 3; x++) {
							if (x != 0 || y != 0) 
							{
								ctx.globalAlpha = 1 - Math.abs(y) * 0.1 - Math.abs(x * 0.1);
								ctx.drawImage(levelCanvas, cameraX + horWidth * x, cameraY + verHeight * y);
							}
						}
					}

					ctx.globalAlpha = 1;
					ctx.drawImage(levelCanvas, cameraX, cameraY);

					//QQQ
					roughCanvas.rectangle(50,50,canvas.width - 100, 50, {fill: "solid", fillWeight: 4, fillStyle: "white", seed: 1});
					ctx.font = "24px sans-serif";
					ctx.fillStyle = "white";
					ctx.fillText("Todo: Level Select, Puzzles, Tweens, More block types, Keep under 13KB, Optimization. Deadline 13 September!",60,80)
				}
				catch (e) {
						console.error("Whoops! Something went wrong and the game crashed. The cause:", e)
						console.log("Here's some extra info to help resolve the issue. (It might contain some personal information.)")
						console.log("Your user agent is:",navigator.userAgent)
						console.log("Are your cookies enabled?",navigator.cookieEnabled)
						console.log("Are you online?",navigator.onLine)
						console.log("The language your browser is set to:",navigator.language)
						
						const canvas = document.getElementById("canvas");
						if (canvas) {
							console.log("Size of the canvas:",{width: canvas.width, height: canvas.height})
						}

						clearInterval(gameLoop);
					}
			}, 0);

			function drawLevel(rghCanvas,rootX,rootY, gridWidth, gridHeight, localScale, lineWidth, seed) {

				var off = 10;

				//Player
				rghCanvas.circle(PosX(player.x) + localScale * 0.5, PosY(player.y) + localScale * 0.5,localScale * 0.8, {strokeWidth: 1 * lineWidth, seed: seed});
				
				//Walls
				for(let i = 0; i != walls.length; i++) {
					rghCanvas.rectangle(PosX(walls[i].x),PosY(walls[i].y),localScale,localScale, {fill: "solid", strokeWidth: 1 * lineWidth, seed: seed});
				}

				//Boxes
				for(let i = 0; i != boxes.length; i++) {
					rghCanvas.rectangle(PosX(boxes[i].x),PosY(boxes[i].y),localScale,localScale, {fill: "dots", strokeWidth: 2 * lineWidth, seed: seed});
				}

				//Target
				for(let i = 0; i != targets.length; i++) {
					rghCanvas.circle(PosX(targets[i].x) + localScale * 0.5, PosY(targets[i].y) + localScale * 0.5,localScale * 1.1, {fillStyle: "zigzag", fill: "#888", strokeWidth: 1 * lineWidth, seed: seed});
				}

				function PosX(val) {
					return (rootX + off + val * localScale);
				}

				function PosY(val) {
					return (rootY + off + val * localScale);
				}
			}

			function input(key) {

				if (key == "r") {
					loadLevel(level);
					return;
				} else 

				if (key == "+") {
					loadLevel(Math.min(level + 1, levels.length-1 ))
					return;
				}

				if (key == "-") {
					loadLevel(Math.max(level - 1, 0 ))
					return;
				}

				var dir = "";

				var horDelta = 0; 
				if (key == "ArrowLeft" || key == "a" || key == "q") {horDelta = -1; dir = "l"}
				if (key == "ArrowRight" || key == "d") {horDelta = 1; dir = "r"}

				var verDelta = 0;
				if (key == "ArrowDown" || key == "s") {verDelta = 1; dir = "d"}
				if (key == "ArrowUp" || key == "w") {verDelta = -1; dir = "u"}

				console.log("------");

				if (horDelta != 0 || verDelta != 0) {
					var movementResolved = false;

					var targetX = (player.x + gridWidth + horDelta) % gridWidth;
					var targetY = (player.y + gridHeight + verDelta) % gridHeight;

					console.log("x:"+player.x+"y:"+player.y+" tx:"+targetX+"ty:"+targetY);

					let foundBox = hasBox(targetX, targetY);
					console.log("fb: "+foundBox);
					if (foundBox !== null) {
						let boxTargetX = (targetX + gridWidth + horDelta) % gridWidth;
						let boxTargetY = (targetY + gridHeight + verDelta) % gridHeight;

						//console.log("bx: "+boxTargetX+" by:"+boxTargetY);
						//console.log("hasWall:",hasWall(boxTargetX, boxTargetY))
						if (hasWall(boxTargetX, boxTargetY) === null && hasBox(boxTargetX, boxTargetY) === null) {
							boxes[foundBox] = {x: boxTargetX, y: boxTargetY}
							player = {x: targetX, y: targetY}
							movementResolved = true;
						} else {
							console.log("Movement not resolved","Could not push box")
						}
					}
					else if (hasWall(targetX, targetY) === null) {
						player = {x: targetX, y: targetY}
						movementResolved = true;
					} else {
						console.log("Movement not resolved","Something was in the way")
					}
				}

				if (movementResolved) {

					steps += dir;

					//Check if won
					var victory = true;
					for(let i = 0; i != targets.length; i++) {
						if (hasBox(targets[i].x, targets[i].y) === null) {
							victory = false; break;
						}
					}

					if (victory) {
						console.warn("Victory!",steps + " (" + steps.length + ")");
					}
				}
			}

			function loadLevel(number) {
				level = number;

				gridHeight = levels[number].length;
				gridWidth = levels[number][0].length;
				
				player = {x: 0, y: 0};
				walls = [];
				boxes = [];
				targets = [];

				for(let y = 0; y != gridHeight; y++) {
					for(let x = 0; x != gridWidth; x++) {
						if (levels[number][y][x]) {
							switch (levels[number][y][x]) {
								case obj.PLAYER:
									this.player = {x: x, y: y}
									break;
								case obj.WALL:
									walls.push({x: x, y: y})
									break;
								case obj.BOX:
									boxes.push({x: x, y: y})
									break;
								case obj.TARGET:
									targets.push({x: x, y: y})
									break;
							}
						}
					}
				}
			}

			function hasThing(array, x, y) {
				for(let i = 0; i != array.length; i++) {
					if (array[i].x == x && array[i].y == y) {
						return i;
					}
				}
				return null;
			}

			function hasWall(x, y) {
				return hasThing(walls, x, y)
			}

			function hasBox(x, y) {
				return hasThing(boxes, x, y)
			}

			function hasTarget(x, y) {
				return hasThing(targets, x, y)
			}
		</script>
	</body>
</html>